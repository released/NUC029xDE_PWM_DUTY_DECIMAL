; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\spi.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\spi.d --cpu=Cortex-M0 --apcs=interwork --diag_suppress=9931 -I..\..\..\Library\CMSIS\Include -I..\..\..\Library\Device\Nuvoton\NUC029xDE\Include -I..\..\..\Library\StdDriver\inc -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=526 --omf_browse=.\obj\spi.crf ..\..\..\Library\StdDriver\src\spi.c]
                          THUMB

                          AREA ||i.CLK_GetPLLClockFreq||, CODE, READONLY, ALIGN=2

                  CLK_GetPLLClockFreq PROC
;;;270      */
;;;271    __STATIC_INLINE uint32_t CLK_GetPLLClockFreq(void)
000000  b508              PUSH     {r3,lr}
;;;272    {
;;;273        uint32_t u32PllFreq = 0, u32PllReg;
;;;274        uint32_t u32FIN, u32NF, u32NR, u32NO;
;;;275        uint8_t au8NoTbl[4] = {1, 2, 2, 4};
000002  a011              ADR      r0,|L1.72|
000004  6800              LDR      r0,[r0,#0]
;;;276    
;;;277        u32PllReg = CLK->PLLCON;
000006  9000              STR      r0,[sp,#0]
000008  4810              LDR      r0,|L1.76|
00000a  6a01              LDR      r1,[r0,#0x20]
;;;278    
;;;279        if(u32PllReg & (CLK_PLLCON_PD_Msk | CLK_PLLCON_OE_Msk))
00000c  1300              ASRS     r0,r0,#12
00000e  4201              TST      r1,r0
000010  d001              BEQ      |L1.22|
;;;280            return 0;           /* PLL is in power down mode or fix low */
000012  2000              MOVS     r0,#0
                  |L1.20|
;;;281    
;;;282        if(u32PllReg & CLK_PLLCON_PLL_SRC_HIRC)
;;;283            u32FIN = __HIRC;    /* PLL source clock from HIRC */
;;;284        else
;;;285            u32FIN = __HXT;     /* PLL source clock from HXT */
;;;286    
;;;287        if(u32PllReg & CLK_PLLCON_BP_Msk)
;;;288            return u32FIN;      /* PLL is in bypass mode */
;;;289    
;;;290        /* PLL is output enabled in normal work mode */
;;;291        u32NO = au8NoTbl[((u32PllReg & CLK_PLLCON_OUT_DV_Msk) >> CLK_PLLCON_OUT_DV_Pos)];
;;;292        u32NF = ((u32PllReg & CLK_PLLCON_FB_DV_Msk) >> CLK_PLLCON_FB_DV_Pos) + 2;
;;;293        u32NR = ((u32PllReg & CLK_PLLCON_IN_DV_Msk) >> CLK_PLLCON_IN_DV_Pos) + 2;
;;;294    
;;;295        /* u32FIN is shifted 2 bits to avoid overflow */
;;;296        u32PllFreq = (((u32FIN >> 2) * u32NF) / (u32NR * u32NO) << 2);
;;;297    
;;;298        return u32PllFreq;
;;;299    }
000014  bd08              POP      {r3,pc}
                  |L1.22|
000016  0308              LSLS     r0,r1,#12             ;282
000018  d501              BPL      |L1.30|
00001a  480d              LDR      r0,|L1.80|
00001c  e000              B        |L1.32|
                  |L1.30|
00001e  480d              LDR      r0,|L1.84|
                  |L1.32|
000020  038a              LSLS     r2,r1,#14             ;287
000022  d4f7              BMI      |L1.20|
000024  040a              LSLS     r2,r1,#16             ;291
000026  0f92              LSRS     r2,r2,#30             ;291
000028  466b              MOV      r3,sp                 ;291
00002a  5c9b              LDRB     r3,[r3,r2]            ;291
00002c  05ca              LSLS     r2,r1,#23             ;292
00002e  0489              LSLS     r1,r1,#18             ;293
000030  0dd2              LSRS     r2,r2,#23             ;292
000032  0ec9              LSRS     r1,r1,#27             ;293
000034  1c89              ADDS     r1,r1,#2              ;293
000036  0880              LSRS     r0,r0,#2              ;296
000038  1c92              ADDS     r2,r2,#2              ;296
00003a  4359              MULS     r1,r3,r1              ;296
00003c  4350              MULS     r0,r2,r0              ;296
00003e  f7fffffe          BL       __aeabi_uidivmod
000042  0080              LSLS     r0,r0,#2              ;296
000044  bd08              POP      {r3,pc}
;;;300    
                          ENDP

000046  0000              DCW      0x0000
                  |L1.72|
000048  01020204          DCB      1,2,2,4
                  |L1.76|
                          DCD      0x50000200
                  |L1.80|
                          DCD      0x01518000
                  |L1.84|
                          DCD      0x00b71b00

                          AREA ||i.SPI_ClearIntFlag||, CODE, READONLY, ALIGN=1

                  SPI_ClearIntFlag PROC
;;;466      */
;;;467    void SPI_ClearIntFlag(SPI_T *spi, uint32_t u32Mask)
000000  07ca              LSLS     r2,r1,#31
;;;468    {
000002  d004              BEQ      |L2.14|
;;;469        if(u32Mask & SPI_UNIT_INT_MASK)
;;;470            spi->CNTRL |= SPI_CNTRL_IF_Msk; /* Clear unit transfer interrupt flag */
000004  6802              LDR      r2,[r0,#0]
000006  2301              MOVS     r3,#1
000008  041b              LSLS     r3,r3,#16
00000a  431a              ORRS     r2,r2,r3
00000c  6002              STR      r2,[r0,#0]
                  |L2.14|
;;;471    
;;;472        if(u32Mask & SPI_SSTA_INT_MASK)
00000e  078a              LSLS     r2,r1,#30
000010  d504              BPL      |L2.28|
;;;473            spi->CNTRL2 |= SPI_CNTRL2_SLV_START_INTSTS_Msk; /* Clear slave 3-wire mode start interrupt flag */
000012  6bc2              LDR      r2,[r0,#0x3c]
000014  2301              MOVS     r3,#1
000016  02db              LSLS     r3,r3,#11
000018  431a              ORRS     r2,r2,r3
00001a  63c2              STR      r2,[r0,#0x3c]
                  |L2.28|
;;;474    
;;;475        if(u32Mask & SPI_FIFO_RXOV_INT_MASK)
00001c  06ca              LSLS     r2,r1,#27
00001e  d501              BPL      |L2.36|
;;;476            spi->STATUS = SPI_STATUS_RX_OVERRUN_Msk; /* Clear RX overrun interrupt flag */
000020  2204              MOVS     r2,#4
000022  6442              STR      r2,[r0,#0x44]
                  |L2.36|
;;;477    
;;;478        if(u32Mask & SPI_FIFO_TIMEOUT_INT_MASK)
000024  0689              LSLS     r1,r1,#26
000026  d502              BPL      |L2.46|
;;;479            spi->STATUS = SPI_STATUS_TIMEOUT_Msk; /* Clear RX time-out interrupt flag */
000028  2101              MOVS     r1,#1
00002a  0509              LSLS     r1,r1,#20
00002c  6441              STR      r1,[r0,#0x44]
                  |L2.46|
;;;480    }
00002e  4770              BX       lr
;;;481    
                          ENDP


                          AREA ||i.SPI_ClearRxFIFO||, CODE, READONLY, ALIGN=1

                  SPI_ClearRxFIFO PROC
;;;159      */
;;;160    void SPI_ClearRxFIFO(SPI_T *spi)
000000  6c01              LDR      r1,[r0,#0x40]
;;;161    {
;;;162        spi->FIFO_CTL |= SPI_FIFO_CTL_RX_CLR_Msk;
000002  2201              MOVS     r2,#1
000004  4311              ORRS     r1,r1,r2
000006  6401              STR      r1,[r0,#0x40]
;;;163    }
000008  4770              BX       lr
;;;164    
                          ENDP


                          AREA ||i.SPI_ClearTxFIFO||, CODE, READONLY, ALIGN=1

                  SPI_ClearTxFIFO PROC
;;;171      */
;;;172    void SPI_ClearTxFIFO(SPI_T *spi)
000000  6c01              LDR      r1,[r0,#0x40]
;;;173    {
;;;174        spi->FIFO_CTL |= SPI_FIFO_CTL_TX_CLR_Msk;
000002  2202              MOVS     r2,#2
000004  4311              ORRS     r1,r1,r2
000006  6401              STR      r1,[r0,#0x40]
;;;175    }
000008  4770              BX       lr
;;;176    
                          ENDP


                          AREA ||i.SPI_Close||, CODE, READONLY, ALIGN=1

                  SPI_Close PROC
;;;145      */
;;;146    void SPI_Close(SPI_T *spi)
000000  2005              MOVS     r0,#5
;;;147    {
;;;148        /* Reset SPI */
;;;149        SYS->IPRSTC2 |= SYS_IPRSTC2_SPI0_RST_Msk;
000002  0700              LSLS     r0,r0,#28
000004  68c2              LDR      r2,[r0,#0xc]
000006  2101              MOVS     r1,#1
000008  0309              LSLS     r1,r1,#12
00000a  430a              ORRS     r2,r2,r1
00000c  60c2              STR      r2,[r0,#0xc]
;;;150        SYS->IPRSTC2 &= ~SYS_IPRSTC2_SPI0_RST_Msk;
00000e  68c2              LDR      r2,[r0,#0xc]
000010  438a              BICS     r2,r2,r1
000012  60c2              STR      r2,[r0,#0xc]
;;;151    }
000014  4770              BX       lr
;;;152    
                          ENDP


                          AREA ||i.SPI_DisableAutoSS||, CODE, READONLY, ALIGN=1

                  SPI_DisableAutoSS PROC
;;;182      */
;;;183    void SPI_DisableAutoSS(SPI_T *spi)
000000  6881              LDR      r1,[r0,#8]
;;;184    {
;;;185        spi->SSR &= ~(SPI_SSR_AUTOSS_Msk | SPI_SSR_SSR_Msk);
000002  2209              MOVS     r2,#9
000004  4391              BICS     r1,r1,r2
000006  6081              STR      r1,[r0,#8]
;;;186    }
000008  4770              BX       lr
;;;187    
                          ENDP


                          AREA ||i.SPI_DisableFIFO||, CODE, READONLY, ALIGN=1

                  SPI_DisableFIFO PROC
;;;300      */
;;;301    void SPI_DisableFIFO(SPI_T *spi)
000000  6801              LDR      r1,[r0,#0]
;;;302    {
;;;303        spi->CNTRL &= ~SPI_CNTRL_FIFO_Msk;
000002  2201              MOVS     r2,#1
000004  0552              LSLS     r2,r2,#21
000006  4391              BICS     r1,r1,r2
000008  6001              STR      r1,[r0,#0]
;;;304    }
00000a  4770              BX       lr
;;;305    
                          ENDP


                          AREA ||i.SPI_DisableInt||, CODE, READONLY, ALIGN=1

                  SPI_DisableInt PROC
;;;386      */
;;;387    void SPI_DisableInt(SPI_T *spi, uint32_t u32Mask)
000000  07ca              LSLS     r2,r1,#31
;;;388    {
000002  d004              BEQ      |L8.14|
;;;389        /* Disable unit transfer interrupt flag */
;;;390        if((u32Mask & SPI_UNIT_INT_MASK) == SPI_UNIT_INT_MASK)
;;;391            spi->CNTRL &= ~SPI_CNTRL_IE_Msk;
000004  6802              LDR      r2,[r0,#0]
000006  2301              MOVS     r3,#1
000008  045b              LSLS     r3,r3,#17
00000a  439a              BICS     r2,r2,r3
00000c  6002              STR      r2,[r0,#0]
                  |L8.14|
;;;392    
;;;393        /* Disable slave 3-wire mode start interrupt flag */
;;;394        if((u32Mask & SPI_SSTA_INT_MASK) == SPI_SSTA_INT_MASK)
00000e  078a              LSLS     r2,r1,#30
000010  d504              BPL      |L8.28|
;;;395            spi->CNTRL2 &= ~SPI_CNTRL2_SSTA_INTEN_Msk;
000012  6bc2              LDR      r2,[r0,#0x3c]
000014  2301              MOVS     r3,#1
000016  029b              LSLS     r3,r3,#10
000018  439a              BICS     r2,r2,r3
00001a  63c2              STR      r2,[r0,#0x3c]
                  |L8.28|
;;;396    
;;;397        /* Disable TX threshold interrupt flag */
;;;398        if((u32Mask & SPI_FIFO_TX_INT_MASK) == SPI_FIFO_TX_INT_MASK)
00001c  074a              LSLS     r2,r1,#29
00001e  d503              BPL      |L8.40|
;;;399            spi->FIFO_CTL &= ~SPI_FIFO_CTL_TX_INTEN_Msk;
000020  6c02              LDR      r2,[r0,#0x40]
000022  2308              MOVS     r3,#8
000024  439a              BICS     r2,r2,r3
000026  6402              STR      r2,[r0,#0x40]
                  |L8.40|
;;;400    
;;;401        /* Disable RX threshold interrupt flag */
;;;402        if((u32Mask & SPI_FIFO_RX_INT_MASK) == SPI_FIFO_RX_INT_MASK)
000028  070a              LSLS     r2,r1,#28
00002a  d503              BPL      |L8.52|
;;;403            spi->FIFO_CTL &= ~SPI_FIFO_CTL_RX_INTEN_Msk;
00002c  6c02              LDR      r2,[r0,#0x40]
00002e  2304              MOVS     r3,#4
000030  439a              BICS     r2,r2,r3
000032  6402              STR      r2,[r0,#0x40]
                  |L8.52|
;;;404    
;;;405        /* Disable RX overrun interrupt flag */
;;;406        if((u32Mask & SPI_FIFO_RXOV_INT_MASK) == SPI_FIFO_RXOV_INT_MASK)
000034  06ca              LSLS     r2,r1,#27
000036  d503              BPL      |L8.64|
;;;407            spi->FIFO_CTL &= ~SPI_FIFO_CTL_RXOV_INTEN_Msk;
000038  6c02              LDR      r2,[r0,#0x40]
00003a  2340              MOVS     r3,#0x40
00003c  439a              BICS     r2,r2,r3
00003e  6402              STR      r2,[r0,#0x40]
                  |L8.64|
;;;408    
;;;409        /* Disable RX time-out interrupt flag */
;;;410        if((u32Mask & SPI_FIFO_TIMEOUT_INT_MASK) == SPI_FIFO_TIMEOUT_INT_MASK)
000040  0689              LSLS     r1,r1,#26
000042  d504              BPL      |L8.78|
;;;411            spi->FIFO_CTL &= ~SPI_FIFO_CTL_TIMEOUT_INTEN_Msk;
000044  6c01              LDR      r1,[r0,#0x40]
000046  2201              MOVS     r2,#1
000048  0552              LSLS     r2,r2,#21
00004a  4391              BICS     r1,r1,r2
00004c  6401              STR      r1,[r0,#0x40]
                  |L8.78|
;;;412    }
00004e  4770              BX       lr
;;;413    
                          ENDP


                          AREA ||i.SPI_EnableAutoSS||, CODE, READONLY, ALIGN=1

                  SPI_EnableAutoSS PROC
;;;196      */
;;;197    void SPI_EnableAutoSS(SPI_T *spi, uint32_t u32SSPinMask, uint32_t u32ActiveLevel)
000000  b510              PUSH     {r4,lr}
;;;198    {
;;;199        spi->SSR = (spi->SSR & (~(SPI_SSR_AUTOSS_Msk | SPI_SSR_SS_LVL_Msk | SPI_SSR_SSR_Msk))) | (u32SSPinMask | u32ActiveLevel | SPI_SSR_AUTOSS_Msk);
000002  6883              LDR      r3,[r0,#8]
000004  240d              MOVS     r4,#0xd
000006  43a3              BICS     r3,r3,r4
000008  4311              ORRS     r1,r1,r2
00000a  430b              ORRS     r3,r3,r1
00000c  2108              MOVS     r1,#8
00000e  430b              ORRS     r3,r3,r1
000010  6083              STR      r3,[r0,#8]
;;;200    }
000012  bd10              POP      {r4,pc}
;;;201    
                          ENDP


                          AREA ||i.SPI_EnableFIFO||, CODE, READONLY, ALIGN=1

                  SPI_EnableFIFO PROC
;;;285      */
;;;286    void SPI_EnableFIFO(SPI_T *spi, uint32_t u32TxThreshold, uint32_t u32RxThreshold)
000000  b510              PUSH     {r4,lr}
;;;287    {
;;;288        spi->FIFO_CTL = (spi->FIFO_CTL & ~(SPI_FIFO_CTL_TX_THRESHOLD_Msk | SPI_FIFO_CTL_RX_THRESHOLD_Msk)) |
000002  6c03              LDR      r3,[r0,#0x40]
000004  2477              MOVS     r4,#0x77
000006  0624              LSLS     r4,r4,#24
000008  43a3              BICS     r3,r3,r4
00000a  0709              LSLS     r1,r1,#28
00000c  430b              ORRS     r3,r3,r1
00000e  0611              LSLS     r1,r2,#24
000010  430b              ORRS     r3,r3,r1
000012  6403              STR      r3,[r0,#0x40]
;;;289                        (u32TxThreshold << SPI_FIFO_CTL_TX_THRESHOLD_Pos) |
;;;290                        (u32RxThreshold << SPI_FIFO_CTL_RX_THRESHOLD_Pos);
;;;291    
;;;292        spi->CNTRL |= SPI_CNTRL_FIFO_Msk;
000014  6801              LDR      r1,[r0,#0]
000016  2201              MOVS     r2,#1
000018  0552              LSLS     r2,r2,#21
00001a  4311              ORRS     r1,r1,r2
00001c  6001              STR      r1,[r0,#0]
;;;293    }
00001e  bd10              POP      {r4,pc}
;;;294    
                          ENDP


                          AREA ||i.SPI_EnableInt||, CODE, READONLY, ALIGN=1

                  SPI_EnableInt PROC
;;;348      */
;;;349    void SPI_EnableInt(SPI_T *spi, uint32_t u32Mask)
000000  07ca              LSLS     r2,r1,#31
;;;350    {
000002  d004              BEQ      |L11.14|
;;;351        /* Enable unit transfer interrupt flag */
;;;352        if((u32Mask & SPI_UNIT_INT_MASK) == SPI_UNIT_INT_MASK)
;;;353            spi->CNTRL |= SPI_CNTRL_IE_Msk;
000004  6802              LDR      r2,[r0,#0]
000006  2301              MOVS     r3,#1
000008  045b              LSLS     r3,r3,#17
00000a  431a              ORRS     r2,r2,r3
00000c  6002              STR      r2,[r0,#0]
                  |L11.14|
;;;354    
;;;355        /* Enable slave 3-wire mode start interrupt flag */
;;;356        if((u32Mask & SPI_SSTA_INT_MASK) == SPI_SSTA_INT_MASK)
00000e  078a              LSLS     r2,r1,#30
000010  d504              BPL      |L11.28|
;;;357            spi->CNTRL2 |= SPI_CNTRL2_SSTA_INTEN_Msk;
000012  6bc2              LDR      r2,[r0,#0x3c]
000014  2301              MOVS     r3,#1
000016  029b              LSLS     r3,r3,#10
000018  431a              ORRS     r2,r2,r3
00001a  63c2              STR      r2,[r0,#0x3c]
                  |L11.28|
;;;358    
;;;359        /* Enable TX threshold interrupt flag */
;;;360        if((u32Mask & SPI_FIFO_TX_INT_MASK) == SPI_FIFO_TX_INT_MASK)
00001c  074a              LSLS     r2,r1,#29
00001e  d503              BPL      |L11.40|
;;;361            spi->FIFO_CTL |= SPI_FIFO_CTL_TX_INTEN_Msk;
000020  6c02              LDR      r2,[r0,#0x40]
000022  2308              MOVS     r3,#8
000024  431a              ORRS     r2,r2,r3
000026  6402              STR      r2,[r0,#0x40]
                  |L11.40|
;;;362    
;;;363        /* Enable RX threshold interrupt flag */
;;;364        if((u32Mask & SPI_FIFO_RX_INT_MASK) == SPI_FIFO_RX_INT_MASK)
000028  070a              LSLS     r2,r1,#28
00002a  d503              BPL      |L11.52|
;;;365            spi->FIFO_CTL |= SPI_FIFO_CTL_RX_INTEN_Msk;
00002c  6c02              LDR      r2,[r0,#0x40]
00002e  2304              MOVS     r3,#4
000030  431a              ORRS     r2,r2,r3
000032  6402              STR      r2,[r0,#0x40]
                  |L11.52|
;;;366    
;;;367        /* Enable RX overrun interrupt flag */
;;;368        if((u32Mask & SPI_FIFO_RXOV_INT_MASK) == SPI_FIFO_RXOV_INT_MASK)
000034  06ca              LSLS     r2,r1,#27
000036  d503              BPL      |L11.64|
;;;369            spi->FIFO_CTL |= SPI_FIFO_CTL_RXOV_INTEN_Msk;
000038  6c02              LDR      r2,[r0,#0x40]
00003a  2340              MOVS     r3,#0x40
00003c  431a              ORRS     r2,r2,r3
00003e  6402              STR      r2,[r0,#0x40]
                  |L11.64|
;;;370    
;;;371        /* Enable RX time-out interrupt flag */
;;;372        if((u32Mask & SPI_FIFO_TIMEOUT_INT_MASK) == SPI_FIFO_TIMEOUT_INT_MASK)
000040  0689              LSLS     r1,r1,#26
000042  d504              BPL      |L11.78|
;;;373            spi->FIFO_CTL |= SPI_FIFO_CTL_TIMEOUT_INTEN_Msk;
000044  6c01              LDR      r1,[r0,#0x40]
000046  2201              MOVS     r2,#1
000048  0552              LSLS     r2,r2,#21
00004a  4311              ORRS     r1,r1,r2
00004c  6401              STR      r1,[r0,#0x40]
                  |L11.78|
;;;374    }
00004e  4770              BX       lr
;;;375    
                          ENDP


                          AREA ||i.SPI_GetBusClock||, CODE, READONLY, ALIGN=2

                  SPI_GetBusClock PROC
;;;311      */
;;;312    uint32_t SPI_GetBusClock(SPI_T *spi)
000000  b570              PUSH     {r4-r6,lr}
;;;313    {
000002  4605              MOV      r5,r0
;;;314        uint32_t u32Div;
;;;315        uint32_t u32ClkSrc;
;;;316    
;;;317        /* Get DIVIDER setting */
;;;318        u32Div = (spi->DIVIDER & SPI_DIVIDER_DIVIDER_Msk) >> SPI_DIVIDER_DIVIDER_Pos;
000004  6840              LDR      r0,[r0,#4]
000006  b2c4              UXTB     r4,r0
;;;319    
;;;320        /* Check clock source of SPI */
;;;321        if((CLK->CLKSEL1 & CLK_CLKSEL1_SPI0_S_Msk) == CLK_CLKSEL1_SPI0_S_HCLK)
000008  4809              LDR      r0,|L12.48|
00000a  6940              LDR      r0,[r0,#0x14]
00000c  06c0              LSLS     r0,r0,#27
00000e  d502              BPL      |L12.22|
;;;322            u32ClkSrc = CLK_GetHCLKFreq();
000010  f7fffffe          BL       CLK_GetHCLKFreq
000014  e001              B        |L12.26|
                  |L12.22|
;;;323        else
;;;324            u32ClkSrc = CLK_GetPLLClockFreq();
000016  f7fffffe          BL       CLK_GetPLLClockFreq
                  |L12.26|
;;;325    
;;;326        if(spi->CNTRL2 & SPI_CNTRL2_BCn_Msk)   /* BCn = 1: f_spi = f_spi_clk_src / (DIVIDER + 1) */
00001a  6be9              LDR      r1,[r5,#0x3c]
00001c  2900              CMP      r1,#0
00001e  da01              BGE      |L12.36|
;;;327        {
;;;328            /* Return SPI bus clock rate */
;;;329            return (u32ClkSrc / (u32Div + 1));
000020  1c61              ADDS     r1,r4,#1
000022  e001              B        |L12.40|
                  |L12.36|
;;;330        }
;;;331        else     /* BCn = 0: f_spi = f_spi_clk_src / ((DIVIDER + 1) * 2) */
;;;332        {
;;;333            /* Return SPI bus clock rate */
;;;334            return (u32ClkSrc / ((u32Div + 1) * 2));
000024  0061              LSLS     r1,r4,#1
000026  1c89              ADDS     r1,r1,#2
                  |L12.40|
000028  f7fffffe          BL       __aeabi_uidivmod
;;;335        }
;;;336    }
00002c  bd70              POP      {r4-r6,pc}
;;;337    
                          ENDP

00002e  0000              DCW      0x0000
                  |L12.48|
                          DCD      0x50000200

                          AREA ||i.SPI_GetIntFlag||, CODE, READONLY, ALIGN=1

                  SPI_GetIntFlag PROC
;;;424      */
;;;425    uint32_t SPI_GetIntFlag(SPI_T *spi, uint32_t u32Mask)
000000  4602              MOV      r2,r0
;;;426    {
;;;427        uint32_t u32IntFlag = 0;
000002  2000              MOVS     r0,#0
;;;428    
;;;429        /* Check unit transfer interrupt flag */
;;;430        if((u32Mask & SPI_UNIT_INT_MASK) && (spi->CNTRL & SPI_CNTRL_IF_Msk))
000004  07cb              LSLS     r3,r1,#31
000006  d003              BEQ      |L13.16|
000008  6813              LDR      r3,[r2,#0]
00000a  03db              LSLS     r3,r3,#15
00000c  d500              BPL      |L13.16|
;;;431            u32IntFlag |= SPI_UNIT_INT_MASK;
00000e  2001              MOVS     r0,#1
                  |L13.16|
;;;432    
;;;433        /* Check slave 3-wire mode start interrupt flag */
;;;434        if((u32Mask & SPI_SSTA_INT_MASK) && (spi->CNTRL2 & SPI_CNTRL2_SLV_START_INTSTS_Msk))
000010  078b              LSLS     r3,r1,#30
000012  d504              BPL      |L13.30|
000014  6bd3              LDR      r3,[r2,#0x3c]
000016  051b              LSLS     r3,r3,#20
000018  d501              BPL      |L13.30|
;;;435            u32IntFlag |= SPI_SSTA_INT_MASK;
00001a  2302              MOVS     r3,#2
00001c  4318              ORRS     r0,r0,r3
                  |L13.30|
;;;436    
;;;437        /* Check TX threshold interrupt flag */
;;;438        if((u32Mask & SPI_FIFO_TX_INT_MASK) && (spi->STATUS & SPI_STATUS_TX_INTSTS_Msk))
00001e  074b              LSLS     r3,r1,#29
000020  d504              BPL      |L13.44|
000022  6c53              LDR      r3,[r2,#0x44]
000024  06db              LSLS     r3,r3,#27
000026  d501              BPL      |L13.44|
;;;439            u32IntFlag |= SPI_FIFO_TX_INT_MASK;
000028  2304              MOVS     r3,#4
00002a  4318              ORRS     r0,r0,r3
                  |L13.44|
;;;440    
;;;441        /* Check RX threshold interrupt flag */
;;;442        if((u32Mask & SPI_FIFO_RX_INT_MASK) && (spi->STATUS & SPI_STATUS_RX_INTSTS_Msk))
00002c  070b              LSLS     r3,r1,#28
00002e  d504              BPL      |L13.58|
000030  6c53              LDR      r3,[r2,#0x44]
000032  07db              LSLS     r3,r3,#31
000034  d001              BEQ      |L13.58|
;;;443            u32IntFlag |= SPI_FIFO_RX_INT_MASK;
000036  2308              MOVS     r3,#8
000038  4318              ORRS     r0,r0,r3
                  |L13.58|
;;;444    
;;;445        /* Check RX overrun interrupt flag */
;;;446        if((u32Mask & SPI_FIFO_RXOV_INT_MASK) && (spi->STATUS & SPI_STATUS_RX_OVERRUN_Msk))
00003a  06cb              LSLS     r3,r1,#27
00003c  d504              BPL      |L13.72|
00003e  6c53              LDR      r3,[r2,#0x44]
000040  075b              LSLS     r3,r3,#29
000042  d501              BPL      |L13.72|
;;;447            u32IntFlag |= SPI_FIFO_RXOV_INT_MASK;
000044  2310              MOVS     r3,#0x10
000046  4318              ORRS     r0,r0,r3
                  |L13.72|
;;;448    
;;;449        /* Check RX time-out interrupt flag */
;;;450        if((u32Mask & SPI_FIFO_TIMEOUT_INT_MASK) && (spi->STATUS & SPI_STATUS_TIMEOUT_Msk))
000048  0689              LSLS     r1,r1,#26
00004a  d504              BPL      |L13.86|
00004c  6c51              LDR      r1,[r2,#0x44]
00004e  02c9              LSLS     r1,r1,#11
000050  d501              BPL      |L13.86|
;;;451            u32IntFlag |= SPI_FIFO_TIMEOUT_INT_MASK;
000052  2120              MOVS     r1,#0x20
000054  4308              ORRS     r0,r0,r1
                  |L13.86|
;;;452    
;;;453        return u32IntFlag;
;;;454    }
000056  4770              BX       lr
;;;455    
                          ENDP


                          AREA ||i.SPI_GetStatus||, CODE, READONLY, ALIGN=1

                  SPI_GetStatus PROC
;;;492      */
;;;493    uint32_t SPI_GetStatus(SPI_T *spi, uint32_t u32Mask)
000000  4602              MOV      r2,r0
;;;494    {
;;;495        uint32_t u32Flag = 0;
000002  2000              MOVS     r0,#0
;;;496    
;;;497        /* Check busy status */
;;;498        if((u32Mask & SPI_BUSY_MASK) && (spi->CNTRL & SPI_CNTRL_GO_BUSY_Msk))
000004  07cb              LSLS     r3,r1,#31
000006  d003              BEQ      |L14.16|
000008  6813              LDR      r3,[r2,#0]
00000a  07db              LSLS     r3,r3,#31
00000c  d000              BEQ      |L14.16|
;;;499            u32Flag |= SPI_BUSY_MASK;
00000e  2001              MOVS     r0,#1
                  |L14.16|
;;;500    
;;;501        /* Check RX empty flag */
;;;502        if((u32Mask & SPI_RX_EMPTY_MASK) && (spi->CNTRL & SPI_CNTRL_RX_EMPTY_Msk))
000010  078b              LSLS     r3,r1,#30
000012  d504              BPL      |L14.30|
000014  6813              LDR      r3,[r2,#0]
000016  01db              LSLS     r3,r3,#7
000018  d501              BPL      |L14.30|
;;;503            u32Flag |= SPI_RX_EMPTY_MASK;
00001a  2302              MOVS     r3,#2
00001c  4318              ORRS     r0,r0,r3
                  |L14.30|
;;;504    
;;;505        /* Check RX full flag */
;;;506        if((u32Mask & SPI_RX_FULL_MASK) && (spi->CNTRL & SPI_CNTRL_RX_FULL_Msk))
00001e  074b              LSLS     r3,r1,#29
000020  d504              BPL      |L14.44|
000022  6813              LDR      r3,[r2,#0]
000024  019b              LSLS     r3,r3,#6
000026  d501              BPL      |L14.44|
;;;507            u32Flag |= SPI_RX_FULL_MASK;
000028  2304              MOVS     r3,#4
00002a  4318              ORRS     r0,r0,r3
                  |L14.44|
;;;508    
;;;509        /* Check TX empty flag */
;;;510        if((u32Mask & SPI_TX_EMPTY_MASK) && (spi->CNTRL & SPI_CNTRL_TX_EMPTY_Msk))
00002c  070b              LSLS     r3,r1,#28
00002e  d504              BPL      |L14.58|
000030  6813              LDR      r3,[r2,#0]
000032  015b              LSLS     r3,r3,#5
000034  d501              BPL      |L14.58|
;;;511            u32Flag |= SPI_TX_EMPTY_MASK;
000036  2308              MOVS     r3,#8
000038  4318              ORRS     r0,r0,r3
                  |L14.58|
;;;512    
;;;513        /* Check TX full flag */
;;;514        if((u32Mask & SPI_TX_FULL_MASK) && (spi->CNTRL & SPI_CNTRL_TX_FULL_Msk))
00003a  06c9              LSLS     r1,r1,#27
00003c  d504              BPL      |L14.72|
00003e  6811              LDR      r1,[r2,#0]
000040  0109              LSLS     r1,r1,#4
000042  d501              BPL      |L14.72|
;;;515            u32Flag |= SPI_TX_FULL_MASK;
000044  2110              MOVS     r1,#0x10
000046  4308              ORRS     r0,r0,r1
                  |L14.72|
;;;516    
;;;517        return u32Flag;
;;;518    }
000048  4770              BX       lr
;;;519    
                          ENDP


                          AREA ||i.SPI_Open||, CODE, READONLY, ALIGN=2

                  SPI_Open PROC
;;;44       */
;;;45     uint32_t SPI_Open(SPI_T *spi,
000000  b5f8              PUSH     {r3-r7,lr}
;;;46                       uint32_t u32MasterSlave,
;;;47                       uint32_t u32SPIMode,
;;;48                       uint32_t u32DataWidth,
;;;49                       uint32_t u32BusClock)
;;;50     {
;;;51         uint32_t u32ClkSrc = 0, u32Div, u32HCLKFreq;
;;;52     
;;;53         if(u32DataWidth == 32)
000002  9e06              LDR      r6,[sp,#0x18]
000004  460d              MOV      r5,r1                 ;50
000006  4604              MOV      r4,r0                 ;50
000008  2b20              CMP      r3,#0x20
00000a  d100              BNE      |L15.14|
;;;54             u32DataWidth = 0;
00000c  2300              MOVS     r3,#0
                  |L15.14|
;;;55     
;;;56         /* Default setting: MSB first, disable unit transfer interrupt, SP_CYCLE = 0. */
;;;57         spi->CNTRL = u32MasterSlave | (u32DataWidth << SPI_CNTRL_TX_BIT_LEN_Pos) | (u32SPIMode);
00000e  00d8              LSLS     r0,r3,#3
000010  4328              ORRS     r0,r0,r5
000012  4310              ORRS     r0,r0,r2
000014  6020              STR      r0,[r4,#0]
;;;58     
;;;59         /* Set BCn = 1: f_spi = f_spi_clk_src / (DIVIDER + 1) */
;;;60         spi->CNTRL2 |= SPI_CNTRL2_BCn_Msk;
000016  6be0              LDR      r0,[r4,#0x3c]
000018  2101              MOVS     r1,#1
00001a  07c9              LSLS     r1,r1,#31
00001c  4308              ORRS     r0,r0,r1
00001e  63e0              STR      r0,[r4,#0x3c]
;;;61         /* Get system clock frequency */
;;;62         u32HCLKFreq = CLK_GetHCLKFreq();
000020  f7fffffe          BL       CLK_GetHCLKFreq
000024  4607              MOV      r7,r0
000026  2200              MOVS     r2,#0
;;;63     
;;;64         if(u32MasterSlave == SPI_MASTER)
;;;65         {
;;;66             /* Default setting: slave select signal is active low; disable automatic slave select function. */
;;;67             spi->SSR = SPI_SS_ACTIVE_LOW;
;;;68     
;;;69             /* Check clock source of SPI */
;;;70             if((CLK->CLKSEL1 & CLK_CLKSEL1_SPI0_S_Msk) == CLK_CLKSEL1_SPI0_S_HCLK)
000028  4831              LDR      r0,|L15.240|
00002a  2d00              CMP      r5,#0                 ;64
00002c  d006              BEQ      |L15.60|
;;;71                 u32ClkSrc = u32HCLKFreq;
;;;72             else
;;;73                 u32ClkSrc = CLK_GetPLLClockFreq();
;;;74     
;;;75             if(u32BusClock >= u32HCLKFreq)
;;;76             {
;;;77                 /* Select HCLK as the clock source of SPI */
;;;78                 CLK->CLKSEL1 = (CLK->CLKSEL1 & (~CLK_CLKSEL1_SPI0_S_Msk)) | CLK_CLKSEL1_SPI0_S_HCLK;
;;;79     
;;;80                 /* Set DIVIDER = 0 */
;;;81                 spi->DIVIDER = 0;
;;;82                 /* Return master peripheral clock rate */
;;;83                 return u32HCLKFreq;
;;;84             }
;;;85             else if(u32BusClock >= u32ClkSrc)
;;;86             {
;;;87                 /* Set DIVIDER = 0 */
;;;88                 spi->DIVIDER = 0;
;;;89                 /* Return master peripheral clock rate */
;;;90                 return u32ClkSrc;
;;;91             }
;;;92             else if(u32BusClock == 0)
;;;93             {
;;;94                 /* Set BCn = 0: f_spi = f_spi_clk_src / ((DIVIDER + 1) * 2) */
;;;95                 spi->CNTRL2 &= (~SPI_CNTRL2_BCn_Msk);
;;;96                 /* Set DIVIDER to the maximum value 0xFF */
;;;97                 spi->DIVIDER = (spi->DIVIDER & (~SPI_DIVIDER_DIVIDER_Msk)) | (0xFF << SPI_DIVIDER_DIVIDER_Pos);
;;;98                 /* Return master peripheral clock rate */
;;;99                 return (u32ClkSrc / ((0xFF + 1) * 2));
;;;100            }
;;;101            else
;;;102            {
;;;103                u32Div = (((u32ClkSrc * 10) / u32BusClock + 5) / 10) - 1; /* Round to the nearest integer */
;;;104                if(u32Div > 0xFF)
;;;105                {
;;;106                    /* Set BCn = 0: f_spi = f_spi_clk_src / ((DIVIDER + 1) * 2) */
;;;107                    spi->CNTRL2 &= (~SPI_CNTRL2_BCn_Msk);
;;;108                    u32Div = (((u32ClkSrc * 10) / (u32BusClock * 2) + 5) / 10) - 1; /* Round to the nearest integer */
;;;109                    if(u32Div > 0xFF)
;;;110                        u32Div = 0xFF;
;;;111                    spi->DIVIDER = (spi->DIVIDER & (~SPI_DIVIDER_DIVIDER_Msk)) | (u32Div << SPI_DIVIDER_DIVIDER_Pos);
;;;112                    /* Return master peripheral clock rate */
;;;113                    return (u32ClkSrc / ((u32Div + 1) * 2));
;;;114                }
;;;115                else
;;;116                {
;;;117                    spi->DIVIDER = (spi->DIVIDER & (~SPI_DIVIDER_DIVIDER_Msk)) | (u32Div << SPI_DIVIDER_DIVIDER_Pos);
;;;118                    /* Return master peripheral clock rate */
;;;119                    return (u32ClkSrc / (u32Div + 1));
;;;120                }
;;;121            }
;;;122    
;;;123        }
;;;124        else     /* For slave mode, force the SPI peripheral clock rate to system clock rate. */
;;;125        {
;;;126            /* Default setting: slave select signal is low level active. */
;;;127            spi->SSR = SPI_SSR_SS_LTRIG_Msk;
00002e  2110              MOVS     r1,#0x10
000030  60a1              STR      r1,[r4,#8]
;;;128    
;;;129            /* Select HCLK as the clock source of SPI */
;;;130            CLK->CLKSEL1 = (CLK->CLKSEL1 & (~CLK_CLKSEL1_SPI0_S_Msk)) | CLK_CLKSEL1_SPI0_S_HCLK;
000032  6943              LDR      r3,[r0,#0x14]
000034  430b              ORRS     r3,r3,r1
000036  6143              STR      r3,[r0,#0x14]
;;;131    
;;;132            /* Set DIVIDER = 0 */
;;;133            spi->DIVIDER = 0;
000038  6062              STR      r2,[r4,#4]
;;;134            /* Return slave peripheral clock rate */
;;;135            return u32HCLKFreq;
00003a  e013              B        |L15.100|
                  |L15.60|
00003c  2100              MOVS     r1,#0                 ;67
00003e  60a1              STR      r1,[r4,#8]            ;67
000040  482b              LDR      r0,|L15.240|
000042  6940              LDR      r0,[r0,#0x14]         ;70
000044  06c0              LSLS     r0,r0,#27             ;70
000046  d501              BPL      |L15.76|
000048  463d              MOV      r5,r7                 ;71
00004a  e002              B        |L15.82|
                  |L15.76|
00004c  f7fffffe          BL       CLK_GetPLLClockFreq
000050  4605              MOV      r5,r0                 ;73
                  |L15.82|
000052  42be              CMP      r6,r7                 ;75
000054  d308              BCC      |L15.104|
000056  4826              LDR      r0,|L15.240|
000058  6941              LDR      r1,[r0,#0x14]         ;78
00005a  2210              MOVS     r2,#0x10              ;78
00005c  4311              ORRS     r1,r1,r2              ;78
00005e  6141              STR      r1,[r0,#0x14]         ;78
000060  2000              MOVS     r0,#0                 ;81
000062  6060              STR      r0,[r4,#4]            ;81
                  |L15.100|
000064  4638              MOV      r0,r7
;;;136        }
;;;137    
;;;138    }
000066  bdf8              POP      {r3-r7,pc}
                  |L15.104|
000068  42ae              CMP      r6,r5                 ;85
00006a  d303              BCC      |L15.116|
00006c  2000              MOVS     r0,#0                 ;88
00006e  6060              STR      r0,[r4,#4]            ;88
000070  4628              MOV      r0,r5                 ;90
000072  bdf8              POP      {r3-r7,pc}
                  |L15.116|
000074  2e00              CMP      r6,#0                 ;92
000076  d028              BEQ      |L15.202|
000078  200a              MOVS     r0,#0xa               ;103
00007a  462f              MOV      r7,r5                 ;103
00007c  4347              MULS     r7,r0,r7              ;103
00007e  4631              MOV      r1,r6                 ;103
000080  4638              MOV      r0,r7                 ;103
000082  f7fffffe          BL       __aeabi_uidivmod
000086  210a              MOVS     r1,#0xa               ;103
000088  1d40              ADDS     r0,r0,#5              ;103
00008a  f7fffffe          BL       __aeabi_uidivmod
00008e  1e40              SUBS     r0,r0,#1              ;103
000090  28ff              CMP      r0,#0xff              ;104
000092  d924              BLS      |L15.222|
000094  6be0              LDR      r0,[r4,#0x3c]         ;107
000096  0040              LSLS     r0,r0,#1              ;107
000098  0840              LSRS     r0,r0,#1              ;107
00009a  63e0              STR      r0,[r4,#0x3c]         ;107
00009c  0071              LSLS     r1,r6,#1              ;108
00009e  4638              MOV      r0,r7                 ;108
0000a0  f7fffffe          BL       __aeabi_uidivmod
0000a4  210a              MOVS     r1,#0xa               ;108
0000a6  1d40              ADDS     r0,r0,#5              ;108
0000a8  f7fffffe          BL       __aeabi_uidivmod
0000ac  1e40              SUBS     r0,r0,#1              ;108
0000ae  28ff              CMP      r0,#0xff              ;109
0000b0  d900              BLS      |L15.180|
0000b2  20ff              MOVS     r0,#0xff              ;110
                  |L15.180|
0000b4  6861              LDR      r1,[r4,#4]            ;111
0000b6  0a09              LSRS     r1,r1,#8              ;111
0000b8  0209              LSLS     r1,r1,#8              ;111
0000ba  4301              ORRS     r1,r1,r0              ;111
0000bc  6061              STR      r1,[r4,#4]            ;111
0000be  0041              LSLS     r1,r0,#1              ;113
0000c0  4628              MOV      r0,r5                 ;113
0000c2  1c89              ADDS     r1,r1,#2              ;113
                  |L15.196|
0000c4  f7fffffe          BL       __aeabi_uidivmod
0000c8  bdf8              POP      {r3-r7,pc}
                  |L15.202|
0000ca  6be0              LDR      r0,[r4,#0x3c]         ;95
0000cc  0040              LSLS     r0,r0,#1              ;95
0000ce  0840              LSRS     r0,r0,#1              ;95
0000d0  63e0              STR      r0,[r4,#0x3c]         ;95
0000d2  6860              LDR      r0,[r4,#4]            ;97
0000d4  21ff              MOVS     r1,#0xff              ;97
0000d6  4308              ORRS     r0,r0,r1              ;97
0000d8  6060              STR      r0,[r4,#4]            ;97
0000da  0a68              LSRS     r0,r5,#9              ;99
0000dc  bdf8              POP      {r3-r7,pc}
                  |L15.222|
0000de  6861              LDR      r1,[r4,#4]            ;117
0000e0  0a09              LSRS     r1,r1,#8              ;117
0000e2  0209              LSLS     r1,r1,#8              ;117
0000e4  4301              ORRS     r1,r1,r0              ;117
0000e6  6061              STR      r1,[r4,#4]            ;117
0000e8  1c41              ADDS     r1,r0,#1              ;119
0000ea  4628              MOV      r0,r5                 ;119
0000ec  e7ea              B        |L15.196|
;;;139    
                          ENDP

0000ee  0000              DCW      0x0000
                  |L15.240|
                          DCD      0x50000200

                          AREA ||i.SPI_SetBusClock||, CODE, READONLY, ALIGN=2

                  SPI_SetBusClock PROC
;;;213      */
;;;214    uint32_t SPI_SetBusClock(SPI_T *spi, uint32_t u32BusClock)
000000  b5f8              PUSH     {r3-r7,lr}
;;;215    {
000002  4604              MOV      r4,r0
;;;216        uint32_t u32ClkSrc, u32HCLKFreq;
;;;217        uint32_t u32Div;
;;;218    
;;;219        /* Set BCn = 1: f_spi = f_spi_clk_src / (DIVIDER + 1) */
;;;220        spi->CNTRL2 |= SPI_CNTRL2_BCn_Msk;
000004  6bc0              LDR      r0,[r0,#0x3c]
000006  460e              MOV      r6,r1                 ;215
000008  2101              MOVS     r1,#1
00000a  07c9              LSLS     r1,r1,#31
00000c  4308              ORRS     r0,r0,r1
00000e  63e0              STR      r0,[r4,#0x3c]
;;;221        /* Get system clock frequency */
;;;222        u32HCLKFreq = CLK_GetHCLKFreq();
000010  f7fffffe          BL       CLK_GetHCLKFreq
000014  4607              MOV      r7,r0
;;;223    
;;;224        /* Check clock source of SPI */
;;;225        if((CLK->CLKSEL1 & CLK_CLKSEL1_SPI0_S_Msk) == CLK_CLKSEL1_SPI0_S_HCLK)
000016  482b              LDR      r0,|L16.196|
000018  6940              LDR      r0,[r0,#0x14]
00001a  06c0              LSLS     r0,r0,#27
00001c  d501              BPL      |L16.34|
;;;226            u32ClkSrc = u32HCLKFreq;
00001e  463d              MOV      r5,r7
000020  e002              B        |L16.40|
                  |L16.34|
;;;227        else
;;;228            u32ClkSrc = CLK_GetPLLClockFreq();
000022  f7fffffe          BL       CLK_GetPLLClockFreq
000026  4605              MOV      r5,r0
                  |L16.40|
000028  2100              MOVS     r1,#0
;;;229    
;;;230        if(u32BusClock >= u32HCLKFreq)
00002a  42be              CMP      r6,r7
00002c  d307              BCC      |L16.62|
;;;231        {
;;;232            /* Select HCLK as the clock source of SPI */
;;;233            CLK->CLKSEL1 = (CLK->CLKSEL1 & (~CLK_CLKSEL1_SPI0_S_Msk)) | CLK_CLKSEL1_SPI0_S_HCLK;
00002e  4825              LDR      r0,|L16.196|
000030  6942              LDR      r2,[r0,#0x14]
000032  2310              MOVS     r3,#0x10
000034  431a              ORRS     r2,r2,r3
000036  6142              STR      r2,[r0,#0x14]
;;;234            /* Set DIVIDER = 0 */
;;;235            spi->DIVIDER = 0;
000038  6061              STR      r1,[r4,#4]
;;;236            /* Return master peripheral clock rate */
;;;237            return u32HCLKFreq;
00003a  4638              MOV      r0,r7
;;;238        }
;;;239        else if(u32BusClock >= u32ClkSrc)
;;;240        {
;;;241            /* Set DIVIDER = 0 */
;;;242            spi->DIVIDER = 0;
;;;243            /* Return master peripheral clock rate */
;;;244            return u32ClkSrc;
;;;245        }
;;;246        else if(u32BusClock == 0)
;;;247        {
;;;248            /* Set BCn = 0: f_spi = f_spi_clk_src / ((DIVIDER + 1) * 2) */
;;;249            spi->CNTRL2 &= (~SPI_CNTRL2_BCn_Msk);
;;;250            /* Set DIVIDER to the maximum value 0xFF */
;;;251            spi->DIVIDER = (spi->DIVIDER & (~SPI_DIVIDER_DIVIDER_Msk)) | (0xFF << SPI_DIVIDER_DIVIDER_Pos);
;;;252            /* Return master peripheral clock rate */
;;;253            return (u32ClkSrc / ((0xFF + 1) * 2));
;;;254        }
;;;255        else
;;;256        {
;;;257            u32Div = (((u32ClkSrc * 10) / u32BusClock + 5) / 10) - 1; /* Round to the nearest integer */
;;;258            if(u32Div > 0xFF)
;;;259            {
;;;260                /* Set BCn = 0: f_spi = f_spi_clk_src / ((DIVIDER + 1) * 2) */
;;;261                spi->CNTRL2 &= (~SPI_CNTRL2_BCn_Msk);
;;;262                u32Div = (((u32ClkSrc * 10) / (u32BusClock * 2) + 5) / 10) - 1; /* Round to the nearest integer */
;;;263                if(u32Div > 0xFF)
;;;264                    u32Div = 0xFF;
;;;265                spi->DIVIDER = (spi->DIVIDER & (~SPI_DIVIDER_DIVIDER_Msk)) | (u32Div << SPI_DIVIDER_DIVIDER_Pos);
;;;266                /* Return master peripheral clock rate */
;;;267                return (u32ClkSrc / ((u32Div + 1) * 2));
;;;268            }
;;;269            else
;;;270            {
;;;271                spi->DIVIDER = (spi->DIVIDER & (~SPI_DIVIDER_DIVIDER_Msk)) | (u32Div << SPI_DIVIDER_DIVIDER_Pos);
;;;272                /* Return master peripheral clock rate */
;;;273                return (u32ClkSrc / (u32Div + 1));
;;;274            }
;;;275        }
;;;276    }
00003c  bdf8              POP      {r3-r7,pc}
                  |L16.62|
00003e  42ae              CMP      r6,r5                 ;239
000040  d302              BCC      |L16.72|
000042  6061              STR      r1,[r4,#4]            ;242
000044  4628              MOV      r0,r5                 ;244
000046  bdf8              POP      {r3-r7,pc}
                  |L16.72|
000048  2e00              CMP      r6,#0                 ;246
00004a  d028              BEQ      |L16.158|
00004c  200a              MOVS     r0,#0xa               ;257
00004e  462f              MOV      r7,r5                 ;257
000050  4347              MULS     r7,r0,r7              ;257
000052  4631              MOV      r1,r6                 ;257
000054  4638              MOV      r0,r7                 ;257
000056  f7fffffe          BL       __aeabi_uidivmod
00005a  210a              MOVS     r1,#0xa               ;257
00005c  1d40              ADDS     r0,r0,#5              ;257
00005e  f7fffffe          BL       __aeabi_uidivmod
000062  1e40              SUBS     r0,r0,#1              ;257
000064  28ff              CMP      r0,#0xff              ;258
000066  d924              BLS      |L16.178|
000068  6be0              LDR      r0,[r4,#0x3c]         ;261
00006a  0040              LSLS     r0,r0,#1              ;261
00006c  0840              LSRS     r0,r0,#1              ;261
00006e  63e0              STR      r0,[r4,#0x3c]         ;261
000070  0071              LSLS     r1,r6,#1              ;262
000072  4638              MOV      r0,r7                 ;262
000074  f7fffffe          BL       __aeabi_uidivmod
000078  210a              MOVS     r1,#0xa               ;262
00007a  1d40              ADDS     r0,r0,#5              ;262
00007c  f7fffffe          BL       __aeabi_uidivmod
000080  1e40              SUBS     r0,r0,#1              ;262
000082  28ff              CMP      r0,#0xff              ;263
000084  d900              BLS      |L16.136|
000086  20ff              MOVS     r0,#0xff              ;264
                  |L16.136|
000088  6861              LDR      r1,[r4,#4]            ;265
00008a  0a09              LSRS     r1,r1,#8              ;265
00008c  0209              LSLS     r1,r1,#8              ;265
00008e  4301              ORRS     r1,r1,r0              ;265
000090  6061              STR      r1,[r4,#4]            ;265
000092  0041              LSLS     r1,r0,#1              ;267
000094  4628              MOV      r0,r5                 ;267
000096  1c89              ADDS     r1,r1,#2              ;267
                  |L16.152|
000098  f7fffffe          BL       __aeabi_uidivmod
00009c  bdf8              POP      {r3-r7,pc}
                  |L16.158|
00009e  6be0              LDR      r0,[r4,#0x3c]         ;249
0000a0  0040              LSLS     r0,r0,#1              ;249
0000a2  0840              LSRS     r0,r0,#1              ;249
0000a4  63e0              STR      r0,[r4,#0x3c]         ;249
0000a6  6860              LDR      r0,[r4,#4]            ;251
0000a8  21ff              MOVS     r1,#0xff              ;251
0000aa  4308              ORRS     r0,r0,r1              ;251
0000ac  6060              STR      r0,[r4,#4]            ;251
0000ae  0a68              LSRS     r0,r5,#9              ;253
0000b0  bdf8              POP      {r3-r7,pc}
                  |L16.178|
0000b2  6861              LDR      r1,[r4,#4]            ;271
0000b4  0a09              LSRS     r1,r1,#8              ;271
0000b6  0209              LSLS     r1,r1,#8              ;271
0000b8  4301              ORRS     r1,r1,r0              ;271
0000ba  6061              STR      r1,[r4,#4]            ;271
0000bc  1c41              ADDS     r1,r0,#1              ;273
0000be  4628              MOV      r0,r5                 ;273
0000c0  e7ea              B        |L16.152|
;;;277    
                          ENDP

0000c2  0000              DCW      0x0000
                  |L16.196|
                          DCD      0x50000200

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\Library\\StdDriver\\src\\spi.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___5_spi_c_SPI_Open____REV16|
#line 118 "..\\..\\..\\Library\\CMSIS\\Include\\core_cmInstr.h"
|__asm___5_spi_c_SPI_Open____REV16| PROC
#line 119

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___5_spi_c_SPI_Open____REVSH|
#line 132
|__asm___5_spi_c_SPI_Open____REVSH| PROC
#line 133

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
