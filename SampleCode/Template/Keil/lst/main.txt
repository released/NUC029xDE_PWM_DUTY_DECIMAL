; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\main.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\main.d --cpu=Cortex-M0 --apcs=interwork --diag_suppress=9931 -I..\..\..\Library\CMSIS\Include -I..\..\..\Library\Device\Nuvoton\NUC029xDE\Include -I..\..\..\Library\StdDriver\inc -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=526 --omf_browse=.\obj\main.crf ..\main.c]
                          THUMB

                          AREA ||i.BasicTimer_TIMER3_Init||, CODE, READONLY, ALIGN=2

                  BasicTimer_TIMER3_Init PROC
;;;102    
;;;103    void BasicTimer_TIMER3_Init(void)
000000  b510              PUSH     {r4,lr}
;;;104    {
;;;105        TIMER_Open(TIMER3, TIMER_PERIODIC_MODE, 1000);
000002  4c0a              LDR      r4,|L1.44|
000004  227d              MOVS     r2,#0x7d
000006  2101              MOVS     r1,#1
000008  00d2              LSLS     r2,r2,#3
00000a  06c9              LSLS     r1,r1,#27
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       TIMER_Open
000012  6820              LDR      r0,[r4,#0]
000014  0621              LSLS     r1,r4,#24
000016  4308              ORRS     r0,r0,r1
000018  6020              STR      r0,[r4,#0]
00001a  1488              ASRS     r0,r1,#18
00001c  4904              LDR      r1,|L1.48|
00001e  6008              STR      r0,[r1,#0]
000020  6820              LDR      r0,[r4,#0]
000022  0589              LSLS     r1,r1,#22
000024  4308              ORRS     r0,r0,r1
000026  6020              STR      r0,[r4,#0]
;;;106        TIMER_EnableInt(TIMER3);
;;;107        NVIC_EnableIRQ(TMR3_IRQn);	
;;;108        TIMER_Start(TIMER3);
;;;109    }
000028  bd10              POP      {r4,pc}
;;;110    
                          ENDP

00002a  0000              DCW      0x0000
                  |L1.44|
                          DCD      0x40110020
                  |L1.48|
                          DCD      0xe000e100

                          AREA ||i.GPIO_Init||, CODE, READONLY, ALIGN=2

                  GPIO_Init PROC
;;;111    
;;;112    void GPIO_Init(void)
000000  b510              PUSH     {r4,lr}
;;;113    {
;;;114        GPIO_SetMode(PA, BIT12, GPIO_PMD_OUTPUT);	//led TEST
000002  2201              MOVS     r2,#1
000004  0311              LSLS     r1,r2,#12
000006  4803              LDR      r0,|L2.20|
000008  f7fffffe          BL       GPIO_SetMode
;;;115    	PA12 = 0;	
00000c  4902              LDR      r1,|L2.24|
00000e  2000              MOVS     r0,#0
000010  6308              STR      r0,[r1,#0x30]
;;;116    }
000012  bd10              POP      {r4,pc}
;;;117    
                          ENDP

                  |L2.20|
                          DCD      0x50004000
                  |L2.24|
                          DCD      0x50004200

                          AREA ||i.PWM0_CH0_Init||, CODE, READONLY, ALIGN=2

                  PWM0_CH0_Init PROC
;;;58     
;;;59     void PWM0_CH0_Init(void)
000000  b510              PUSH     {r4,lr}
;;;60     {
;;;61         SYS->GPA_MFP &= ~(SYS_GPA_MFP_PA12_Msk);
000002  2005              MOVS     r0,#5
000004  0700              LSLS     r0,r0,#28
000006  6b02              LDR      r2,[r0,#0x30]
000008  2101              MOVS     r1,#1
00000a  0309              LSLS     r1,r1,#12
00000c  438a              BICS     r2,r2,r1
00000e  6302              STR      r2,[r0,#0x30]
;;;62         SYS->GPA_MFP |= SYS_GPA_MFP_PA12_PWM0_CH0;
000010  6b02              LDR      r2,[r0,#0x30]
000012  430a              ORRS     r2,r2,r1
000014  6302              STR      r2,[r0,#0x30]
;;;63     
;;;64     
;;;65         PWM_ConfigOutputChannel(PWM0, 0, 20000, 0);
000016  4c09              LDR      r4,|L3.60|
000018  2300              MOVS     r3,#0
00001a  4a07              LDR      r2,|L3.56|
00001c  4619              MOV      r1,r3
00001e  4620              MOV      r0,r4
000020  f7fffffe          BL       PWM_ConfigOutputChannel
;;;66         PWM_EnableOutput(PWM0, PWM_CH_0_MASK);
000024  2101              MOVS     r1,#1
000026  4620              MOV      r0,r4
000028  f7fffffe          BL       PWM_EnableOutput
;;;67     
;;;68         /* Start PWM module */
;;;69         PWM_Start(PWM0, PWM_CH_0_MASK);
00002c  2101              MOVS     r1,#1
00002e  4620              MOV      r0,r4
000030  f7fffffe          BL       PWM_Start
;;;70     
;;;71     }
000034  bd10              POP      {r4,pc}
;;;72     
                          ENDP

000036  0000              DCW      0x0000
                  |L3.56|
                          DCD      0x00004e20
                  |L3.60|
                          DCD      0x40040000

                          AREA ||i.PWM0_DUTY_CHANGE||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_percent
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                  PWM0_DUTY_CHANGE PROC
;;;20     
;;;21     void PWM0_DUTY_CHANGE(uint16_t PWM_DUTY_1000)	
000000  b5f8              PUSH     {r3-r7,lr}
;;;22     {
;;;23         /* Assume PWM output frequency is 300Hz and duty ratio is 50%, user can calculate PWM settings by follows.
;;;24            duty ratio = (CMR+1)/(CNR+1)
;;;25            cycle time = CNR+1
;;;26            High level = CMR+1
;;;27            PWM clock source frequency = __HXT = 12000000
;;;28            (CNR+1) = PWM clock source frequency/prescaler/PWM output frequency
;;;29                    = 12000000/2/300 = 20000
;;;30            (Note: CNR is 16 bits, so if calculated value is larger than 65536, user should increase prescale value.)
;;;31            CNR = 19999
;;;32            duty ratio = 50% ==> (CMR+1)/(CNR+1) = 50% ==> CMR = (CNR+1)*0.5-1 = 20000*50/100-1
;;;33            CMR = 9999
;;;34            Prescale value is 1 : prescaler= 2
;;;35         */
;;;36     
;;;37     	
;;;38     	uint16_t PWM_PSC = 1;		
;;;39     	uint16_t CNR = 0;
;;;40     	uint16_t CMR = 0;	
;;;41     
;;;42     //	if (PWM_DUTY_1000 >= 1000)
;;;43     //	{
;;;44     //		PWM_DUTY_1000 = 0;
;;;45     //	}
;;;46     
;;;47     	CNR = PWM_CLOCK/(PWM_PSC+1)/PWM_FREQ - 1;	//299 , PWM clock source frequency/prescaler/PWM output frequency
000002  4f0c              LDR      r7,|L4.52|
000004  4604              MOV      r4,r0                 ;22
;;;48     	CMR = ((CNR+1)*PWM_DUTY_1000/1000) - 1;	//CMR = (CNR+1)*(PWM_DUTY_1000/1000)-1
000006  1c79              ADDS     r1,r7,#1
000008  4348              MULS     r0,r1,r0
00000a  217d              MOVS     r1,#0x7d
00000c  2601              MOVS     r6,#1                 ;38
00000e  00c9              LSLS     r1,r1,#3
000010  f7fffffe          BL       __aeabi_idivmod
000014  1e40              SUBS     r0,r0,#1
000016  b285              UXTH     r5,r0
;;;49     
;;;50     	printf("CNR : %4d , CMR : %4d , TARGET = %4d\r\n" , CNR , CMR , PWM_DUTY_1000);
000018  4623              MOV      r3,r4
00001a  462a              MOV      r2,r5
00001c  4639              MOV      r1,r7
00001e  a006              ADR      r0,|L4.56|
000020  f7fffffe          BL       __2printf
;;;51     
;;;52     	PWM_SET_PRESCALER(PWM0, 0, PWM_PSC);
000024  480e              LDR      r0,|L4.96|
000026  6146              STR      r6,[r0,#0x14]
;;;53         PWM_SET_CNR(PWM0, 0, CNR);
000028  6307              STR      r7,[r0,#0x30]
;;;54         PWM_SET_CMR(PWM0, 0, CMR);
00002a  480d              LDR      r0,|L4.96|
00002c  3040              ADDS     r0,r0,#0x40
00002e  6105              STR      r5,[r0,#0x10]
;;;55     
;;;56     
;;;57     }
000030  bdf8              POP      {r3-r7,pc}
;;;58     
                          ENDP

000032  0000              DCW      0x0000
                  |L4.52|
                          DCD      0x00000bb7
                  |L4.56|
000038  434e5220          DCB      "CNR : %4d , CMR : %4d , TARGET = %4d\r\n",0
00003c  3a202534
000040  64202c20
000044  434d5220
000048  3a202534
00004c  64202c20
000050  54415247
000054  4554203d
000058  20253464
00005c  0d0a00  
00005f  00                DCB      0
                  |L4.96|
                          DCD      0x40040000

                          AREA ||i.TMR3_IRQHandler||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_percent
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  TMR3_IRQHandler PROC
;;;72     
;;;73     void TMR3_IRQHandler(void)
000000  b570              PUSH     {r4-r6,lr}
000002  4914              LDR      r1,|L5.84|
000004  6888              LDR      r0,[r1,#8]
000006  07c0              LSLS     r0,r0,#31
000008  0fc0              LSRS     r0,r0,#31
;;;74     {
00000a  d022              BEQ      |L5.82|
00000c  2001              MOVS     r0,#1
00000e  6088              STR      r0,[r1,#8]
;;;75     	static uint32_t LOG = 0;
;;;76     	static uint16_t CNT = 0;
;;;77     	static uint16_t CNT_LED = 0;
;;;78     
;;;79     
;;;80         if(TIMER_GetIntFlag(TIMER3) == 1)
;;;81         {
;;;82             TIMER_ClearIntFlag(TIMER3);
;;;83     
;;;84     		if (CNT_LED++ >= 500)
000010  4c11              LDR      r4,|L5.88|
000012  2600              MOVS     r6,#0
000014  88a0              LDRH     r0,[r4,#4]  ; CNT_LED
000016  1c41              ADDS     r1,r0,#1
000018  80a1              STRH     r1,[r4,#4]
00001a  21ff              MOVS     r1,#0xff
00001c  31f5              ADDS     r1,r1,#0xf5
;;;85     		{		
;;;86     			CNT_LED = 0;
;;;87     			PWM0_DUTY_CHANGE(PWM_DUTY_1000);
;;;88     
;;;89     			if (PWM_DUTY_1000++ == 1000)
00001e  004d              LSLS     r5,r1,#1
000020  4288              CMP      r0,r1                 ;84
000022  d309              BCC      |L5.56|
000024  80a6              STRH     r6,[r4,#4]            ;86
000026  8820              LDRH     r0,[r4,#0]            ;87  ; PWM_DUTY_1000
000028  f7fffffe          BL       PWM0_DUTY_CHANGE
00002c  8820              LDRH     r0,[r4,#0]  ; PWM_DUTY_1000
00002e  1c41              ADDS     r1,r0,#1
000030  8021              STRH     r1,[r4,#0]
000032  42a8              CMP      r0,r5
000034  d100              BNE      |L5.56|
;;;90     			{
;;;91     				PWM_DUTY_1000 = 1000;	//stop at 100%
000036  8025              STRH     r5,[r4,#0]
                  |L5.56|
;;;92     			}
;;;93     		}
;;;94     
;;;95     		if (CNT++ >= 1000)
000038  8860              LDRH     r0,[r4,#2]  ; CNT
00003a  1c41              ADDS     r1,r0,#1
00003c  8061              STRH     r1,[r4,#2]
00003e  42a8              CMP      r0,r5
000040  d307              BCC      |L5.82|
;;;96     		{		
;;;97     			CNT = 0;
000042  8066              STRH     r6,[r4,#2]
;;;98             	printf("%s : %4d\r\n",__FUNCTION__,LOG++);
000044  68a2              LDR      r2,[r4,#8]  ; LOG
000046  4905              LDR      r1,|L5.92|
000048  1c50              ADDS     r0,r2,#1
00004a  60a0              STR      r0,[r4,#8]  ; LOG
00004c  a004              ADR      r0,|L5.96|
00004e  f7fffffe          BL       __2printf
                  |L5.82|
;;;99     		}
;;;100        }
;;;101    }
000052  bd70              POP      {r4-r6,pc}
;;;102    
                          ENDP

                  |L5.84|
                          DCD      0x40110020
                  |L5.88|
                          DCD      ||.data||
                  |L5.92|
                          DCD      ||.constdata||
                  |L5.96|
000060  2573203a          DCB      "%s : %4d\r\n",0
000064  20253464
000068  0d0a00  
00006b  00                DCB      0

                          AREA ||i.UART0_Init||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_percent
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                  UART0_Init PROC
;;;118    
;;;119    void UART0_Init(void)
000000  b510              PUSH     {r4,lr}
;;;120    {
;;;121        /* Set GPB multi-function pins for UART0 RXD and TXD */
;;;122        SYS->GPB_MFP &= ~(SYS_GPB_MFP_PB0_Msk | SYS_GPB_MFP_PB1_Msk);
000002  2005              MOVS     r0,#5
000004  0700              LSLS     r0,r0,#28
000006  6b41              LDR      r1,[r0,#0x34]
000008  0889              LSRS     r1,r1,#2
00000a  0089              LSLS     r1,r1,#2
00000c  6341              STR      r1,[r0,#0x34]
;;;123        SYS->GPB_MFP |= (SYS_GPB_MFP_PB0_UART0_RXD | SYS_GPB_MFP_PB1_UART0_TXD);
00000e  6b41              LDR      r1,[r0,#0x34]
000010  2203              MOVS     r2,#3
000012  4311              ORRS     r1,r1,r2
000014  6341              STR      r1,[r0,#0x34]
;;;124    
;;;125        SYS_ResetModule(UART0_RST);
000016  4813              LDR      r0,|L6.100|
000018  f7fffffe          BL       SYS_ResetModule
;;;126    
;;;127        /* Configure UART0 and set UART0 baud rate */
;;;128        UART_Open(UART0, 115200);
00001c  4c12              LDR      r4,|L6.104|
00001e  21e1              MOVS     r1,#0xe1
000020  0249              LSLS     r1,r1,#9
000022  4620              MOV      r0,r4
000024  f7fffffe          BL       UART_Open
;;;129    
;;;130    	/* Set UART receive time-out */
;;;131    	UART_SetTimeoutCnt(UART0, 20);
000028  2114              MOVS     r1,#0x14
00002a  4620              MOV      r0,r4
00002c  f7fffffe          BL       UART_SetTimeoutCnt
;;;132    
;;;133    	printf("\r\nCLK_GetCPUFreq : %8d\r\n",CLK_GetCPUFreq());
000030  f7fffffe          BL       CLK_GetCPUFreq
000034  4601              MOV      r1,r0
000036  a00d              ADR      r0,|L6.108|
000038  f7fffffe          BL       __2printf
;;;134    	printf("CLK_GetHCLKFreq : %8d\r\n",CLK_GetHCLKFreq());	
00003c  f7fffffe          BL       CLK_GetHCLKFreq
000040  4601              MOV      r1,r0
000042  a011              ADR      r0,|L6.136|
000044  f7fffffe          BL       __2printf
;;;135    	printf("CLK_GetPCLK0Freq : %8d\r\n",CLK_GetHXTFreq());
000048  f7fffffe          BL       CLK_GetHXTFreq
00004c  4601              MOV      r1,r0
00004e  a014              ADR      r0,|L6.160|
000050  f7fffffe          BL       __2printf
;;;136    	printf("CLK_GetPCLK1Freq : %8d\r\n",CLK_GetPCLKFreq());
000054  f7fffffe          BL       CLK_GetPCLKFreq
000058  4601              MOV      r1,r0
00005a  a018              ADR      r0,|L6.188|
00005c  f7fffffe          BL       __2printf
;;;137    
;;;138    	
;;;139    }
000060  bd10              POP      {r4,pc}
;;;140    
                          ENDP

000062  0000              DCW      0x0000
                  |L6.100|
                          DCD      0x04000010
                  |L6.104|
                          DCD      0x40050000
                  |L6.108|
00006c  0d0a434c          DCB      "\r\nCLK_GetCPUFreq : %8d\r\n",0
000070  4b5f4765
000074  74435055
000078  46726571
00007c  203a2025
000080  38640d0a
000084  00      
000085  00                DCB      0
000086  00                DCB      0
000087  00                DCB      0
                  |L6.136|
000088  434c4b5f          DCB      "CLK_GetHCLKFreq : %8d\r\n",0
00008c  47657448
000090  434c4b46
000094  72657120
000098  3a202538
00009c  640d0a00
                  |L6.160|
0000a0  434c4b5f          DCB      "CLK_GetPCLK0Freq : %8d\r\n",0
0000a4  47657450
0000a8  434c4b30
0000ac  46726571
0000b0  203a2025
0000b4  38640d0a
0000b8  00      
0000b9  00                DCB      0
0000ba  00                DCB      0
0000bb  00                DCB      0
                  |L6.188|
0000bc  434c4b5f          DCB      "CLK_GetPCLK1Freq : %8d\r\n",0
0000c0  47657450
0000c4  434c4b31
0000c8  46726571
0000cc  203a2025
0000d0  38640d0a
0000d4  00      
0000d5  00                DCB      0
0000d6  00                DCB      0
0000d7  00                DCB      0

                          AREA ||i.main||, CODE, READONLY, ALIGN=1

                  main PROC
;;;140    
;;;141    int main()
000000  f7fffffe          BL       SYS_Init
;;;142    {
;;;143        SYS_Init();
;;;144    
;;;145        UART0_Init();
000004  f7fffffe          BL       UART0_Init
;;;146    
;;;147    	GPIO_Init();
000008  f7fffffe          BL       GPIO_Init
;;;148    
;;;149    	PWM0_CH0_Init();
00000c  f7fffffe          BL       PWM0_CH0_Init
;;;150    			
;;;151    	BasicTimer_TIMER3_Init();
000010  f7fffffe          BL       BasicTimer_TIMER3_Init
                  |L7.20|
;;;152    
;;;153        while(1)
000014  e7fe              B        |L7.20|
;;;154        {
;;;155    
;;;156        }
;;;157    }
;;;158    
                          ENDP


                          AREA ||.constdata||, DATA, READONLY, ALIGN=0

                  __FUNCTION__
000000  544d5233          DCB      0x54,0x4d,0x52,0x33
000004  5f495251          DCB      0x5f,0x49,0x52,0x51
000008  48616e64          DCB      0x48,0x61,0x6e,0x64
00000c  6c657200          DCB      0x6c,0x65,0x72,0x00

                          AREA ||.data||, DATA, ALIGN=2

                  PWM_DUTY_1000
000000  0067              DCW      0x0067
                  ||CNT||
000002  0000              DCW      0x0000
                  CNT_LED
000004  0000              DCW      0x0000
000006  0000              DCB      0x00,0x00
                  LOG
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "..\\main.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___6_main_c_565d547e____REV16|
#line 118 "..\\..\\..\\Library\\CMSIS\\Include\\core_cmInstr.h"
|__asm___6_main_c_565d547e____REV16| PROC
#line 119

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___6_main_c_565d547e____REVSH|
#line 132
|__asm___6_main_c_565d547e____REVSH| PROC
#line 133

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***

                  __ARM_use_no_argv EQU 0
