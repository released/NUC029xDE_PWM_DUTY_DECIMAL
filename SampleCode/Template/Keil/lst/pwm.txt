; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\pwm.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\pwm.d --cpu=Cortex-M0 --apcs=interwork --diag_suppress=9931 -I..\..\..\Library\CMSIS\Include -I..\..\..\Library\Device\Nuvoton\NUC029xDE\Include -I..\..\..\Library\StdDriver\inc -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=526 --omf_browse=.\obj\pwm.crf ..\..\..\Library\StdDriver\src\pwm.c]
                          THUMB

                          AREA ||i.CLK_GetPLLClockFreq||, CODE, READONLY, ALIGN=2

                  CLK_GetPLLClockFreq PROC
;;;270      */
;;;271    __STATIC_INLINE uint32_t CLK_GetPLLClockFreq(void)
000000  b508              PUSH     {r3,lr}
;;;272    {
;;;273        uint32_t u32PllFreq = 0, u32PllReg;
;;;274        uint32_t u32FIN, u32NF, u32NR, u32NO;
;;;275        uint8_t au8NoTbl[4] = {1, 2, 2, 4};
000002  a011              ADR      r0,|L1.72|
000004  6800              LDR      r0,[r0,#0]
;;;276    
;;;277        u32PllReg = CLK->PLLCON;
000006  9000              STR      r0,[sp,#0]
000008  4810              LDR      r0,|L1.76|
00000a  6a01              LDR      r1,[r0,#0x20]
;;;278    
;;;279        if(u32PllReg & (CLK_PLLCON_PD_Msk | CLK_PLLCON_OE_Msk))
00000c  1300              ASRS     r0,r0,#12
00000e  4201              TST      r1,r0
000010  d001              BEQ      |L1.22|
;;;280            return 0;           /* PLL is in power down mode or fix low */
000012  2000              MOVS     r0,#0
                  |L1.20|
;;;281    
;;;282        if(u32PllReg & CLK_PLLCON_PLL_SRC_HIRC)
;;;283            u32FIN = __HIRC;    /* PLL source clock from HIRC */
;;;284        else
;;;285            u32FIN = __HXT;     /* PLL source clock from HXT */
;;;286    
;;;287        if(u32PllReg & CLK_PLLCON_BP_Msk)
;;;288            return u32FIN;      /* PLL is in bypass mode */
;;;289    
;;;290        /* PLL is output enabled in normal work mode */
;;;291        u32NO = au8NoTbl[((u32PllReg & CLK_PLLCON_OUT_DV_Msk) >> CLK_PLLCON_OUT_DV_Pos)];
;;;292        u32NF = ((u32PllReg & CLK_PLLCON_FB_DV_Msk) >> CLK_PLLCON_FB_DV_Pos) + 2;
;;;293        u32NR = ((u32PllReg & CLK_PLLCON_IN_DV_Msk) >> CLK_PLLCON_IN_DV_Pos) + 2;
;;;294    
;;;295        /* u32FIN is shifted 2 bits to avoid overflow */
;;;296        u32PllFreq = (((u32FIN >> 2) * u32NF) / (u32NR * u32NO) << 2);
;;;297    
;;;298        return u32PllFreq;
;;;299    }
000014  bd08              POP      {r3,pc}
                  |L1.22|
000016  0308              LSLS     r0,r1,#12             ;282
000018  d501              BPL      |L1.30|
00001a  480d              LDR      r0,|L1.80|
00001c  e000              B        |L1.32|
                  |L1.30|
00001e  480d              LDR      r0,|L1.84|
                  |L1.32|
000020  038a              LSLS     r2,r1,#14             ;287
000022  d4f7              BMI      |L1.20|
000024  040a              LSLS     r2,r1,#16             ;291
000026  0f92              LSRS     r2,r2,#30             ;291
000028  466b              MOV      r3,sp                 ;291
00002a  5c9b              LDRB     r3,[r3,r2]            ;291
00002c  05ca              LSLS     r2,r1,#23             ;292
00002e  0489              LSLS     r1,r1,#18             ;293
000030  0dd2              LSRS     r2,r2,#23             ;292
000032  0ec9              LSRS     r1,r1,#27             ;293
000034  1c89              ADDS     r1,r1,#2              ;293
000036  0880              LSRS     r0,r0,#2              ;296
000038  1c92              ADDS     r2,r2,#2              ;296
00003a  4359              MULS     r1,r3,r1              ;296
00003c  4350              MULS     r0,r2,r0              ;296
00003e  f7fffffe          BL       __aeabi_uidivmod
000042  0080              LSLS     r0,r0,#2              ;296
000044  bd08              POP      {r3,pc}
;;;300    
                          ENDP

000046  0000              DCW      0x0000
                  |L1.72|
000048  01020204          DCB      1,2,2,4
                  |L1.76|
                          DCD      0x50000200
                  |L1.80|
                          DCD      0x01518000
                  |L1.84|
                          DCD      0x00b71b00

                          AREA ||i.PWM_ClearADCTriggerFlag||, CODE, READONLY, ALIGN=1

                  PWM_ClearADCTriggerFlag PROC
;;;291     */
;;;292    void PWM_ClearADCTriggerFlag(PWM_T *pwm, uint32_t u32ChannelNum, uint32_t u32Condition)
000000  2201              MOVS     r2,#1
;;;293    {
;;;294        (pwm)->STATUS = (PWM_STATUS_ADCTRGF0_Msk << u32ChannelNum);
000002  0412              LSLS     r2,r2,#16
000004  408a              LSLS     r2,r2,r1
000006  30ff              ADDS     r0,r0,#0xff
000008  3001              ADDS     r0,#1
00000a  6202              STR      r2,[r0,#0x20]
;;;295    }
00000c  4770              BX       lr
;;;296    
                          ENDP


                          AREA ||i.PWM_ClearCaptureIntFlag||, CODE, READONLY, ALIGN=1

                  PWM_ClearCaptureIntFlag PROC
;;;534     */
;;;535    void PWM_ClearCaptureIntFlag(PWM_T *pwm, uint32_t u32ChannelNum, uint32_t u32Edge)
000000  408a              LSLS     r2,r2,r1
;;;536    {
;;;537        (pwm)->CAPIF = (u32Edge << u32ChannelNum);
000002  30ff              ADDS     r0,r0,#0xff
000004  30ff              ADDS     r0,r0,#0xff
000006  3002              ADDS     r0,#2
000008  6542              STR      r2,[r0,#0x54]
;;;538    }
00000a  4770              BX       lr
;;;539    
                          ENDP


                          AREA ||i.PWM_ClearDutyIntFlag||, CODE, READONLY, ALIGN=2

                  PWM_ClearDutyIntFlag PROC
;;;596     */
;;;597    void PWM_ClearDutyIntFlag(PWM_T *pwm, uint32_t u32ChannelNum)
000000  4a02              LDR      r2,|L4.12|
;;;598    {
;;;599        (pwm)->INTSTS0 = (PWM_INTSTS0_CMPUIF0_Msk | PWM_INTSTS0_CMPDIF0_Msk) << u32ChannelNum;
000002  408a              LSLS     r2,r2,r1
000004  3080              ADDS     r0,r0,#0x80
000006  6682              STR      r2,[r0,#0x68]
;;;600    }
000008  4770              BX       lr
;;;601    
                          ENDP

00000a  0000              DCW      0x0000
                  |L4.12|
                          DCD      0x01010000

                          AREA ||i.PWM_ClearFaultBrakeIntFlag||, CODE, READONLY, ALIGN=1

                  PWM_ClearFaultBrakeIntFlag PROC
;;;693     */
;;;694    void PWM_ClearFaultBrakeIntFlag(PWM_T *pwm, uint32_t u32BrakeSource)
000000  223f              MOVS     r2,#0x3f
;;;695    {
;;;696        (pwm)->INTSTS1 = (0x3f << u32BrakeSource);
000002  408a              LSLS     r2,r2,r1
000004  3080              ADDS     r0,r0,#0x80
000006  66c2              STR      r2,[r0,#0x6c]
;;;697    }
000008  4770              BX       lr
;;;698    
                          ENDP


                          AREA ||i.PWM_ClearPeriodIntFlag||, CODE, READONLY, ALIGN=1

                  PWM_ClearPeriodIntFlag PROC
;;;752     */
;;;753    void PWM_ClearPeriodIntFlag(PWM_T *pwm, uint32_t u32ChannelNum)
000000  084a              LSRS     r2,r1,#1
;;;754    {
;;;755        (pwm)->INTSTS0 = (PWM_INTSTS0_PIF0_Msk << ((u32ChannelNum >> 1) << 1));
000002  0052              LSLS     r2,r2,#1
000004  21ff              MOVS     r1,#0xff
000006  3101              ADDS     r1,#1
000008  4091              LSLS     r1,r1,r2
00000a  3080              ADDS     r0,r0,#0x80
00000c  6681              STR      r1,[r0,#0x68]
;;;756    }
00000e  4770              BX       lr
;;;757    
                          ENDP


                          AREA ||i.PWM_ClearWrapAroundFlag||, CODE, READONLY, ALIGN=1

                  PWM_ClearWrapAroundFlag PROC
;;;960     */
;;;961    void PWM_ClearWrapAroundFlag(PWM_T *pwm, uint32_t u32ChannelNum)
000000  084a              LSRS     r2,r1,#1
;;;962    {
;;;963        (pwm)->STATUS = (PWM_STATUS_CNTMAXF0_Msk << ((u32ChannelNum >> 1) << 1));
000002  0052              LSLS     r2,r2,#1
000004  2101              MOVS     r1,#1
000006  4091              LSLS     r1,r1,r2
000008  30ff              ADDS     r0,r0,#0xff
00000a  3001              ADDS     r0,#1
00000c  6201              STR      r1,[r0,#0x20]
;;;964    }
00000e  4770              BX       lr
;;;965    
                          ENDP


                          AREA ||i.PWM_ClearZeroIntFlag||, CODE, READONLY, ALIGN=1

                  PWM_ClearZeroIntFlag PROC
;;;810     */
;;;811    void PWM_ClearZeroIntFlag(PWM_T *pwm, uint32_t u32ChannelNum)
000000  084a              LSRS     r2,r1,#1
;;;812    {
;;;813        (pwm)->INTSTS0 = (PWM_INTSTS0_ZIF0_Msk << ((u32ChannelNum >> 1) << 1));
000002  0052              LSLS     r2,r2,#1
000004  2101              MOVS     r1,#1
000006  4091              LSLS     r1,r1,r2
000008  3080              ADDS     r0,r0,#0x80
00000a  6681              STR      r1,[r0,#0x68]
;;;814    }
00000c  4770              BX       lr
;;;815    
                          ENDP


                          AREA ||i.PWM_ConfigCaptureChannel||, CODE, READONLY, ALIGN=2

                  PWM_ConfigCaptureChannel PROC
;;;36      */
;;;37     uint32_t PWM_ConfigCaptureChannel(PWM_T *pwm, uint32_t u32ChannelNum, uint32_t u32UnitTimeNsec, uint32_t u32CaptureEdge)
000000  b5ff              PUSH     {r0-r7,lr}
;;;38     {
000002  4605              MOV      r5,r0
000004  b081              SUB      sp,sp,#4
;;;39         uint32_t u32Src;
;;;40         uint32_t u32PWMClockSrc;
;;;41         uint32_t u32NearestUnitTimeNsec;
;;;42         uint16_t u16Prescale = 1, u16CNR = 0xFFFF;
000006  4823              LDR      r0,|L9.148|
;;;43     
;;;44         if(pwm == PWM0)
;;;45             u32Src = CLK->CLKSEL3 & CLK_CLKSEL3_PWM0_S_Msk;
000008  9000              STR      r0,[sp,#0]
00000a  4824              LDR      r0,|L9.156|
00000c  4922              LDR      r1,|L9.152|
00000e  2401              MOVS     r4,#1                 ;42
;;;46         else//(pwm == PWM1)
;;;47             u32Src = CLK->CLKSEL3 & CLK_CLKSEL3_PWM1_S_Msk;
000010  6b40              LDR      r0,[r0,#0x34]
000012  428d              CMP      r5,r1                 ;44
000014  d101              BNE      |L9.26|
000016  0421              LSLS     r1,r4,#16             ;45
000018  e001              B        |L9.30|
                  |L9.26|
00001a  2101              MOVS     r1,#1
00001c  0449              LSLS     r1,r1,#17
                  |L9.30|
00001e  4208              TST      r0,r1
000020  d102              BNE      |L9.40|
;;;48     
;;;49         if(u32Src == 0)
;;;50         {
;;;51             //clock source is from PLL clock
;;;52             u32PWMClockSrc = CLK_GetPLLClockFreq();
000022  f7fffffe          BL       CLK_GetPLLClockFreq
000026  e003              B        |L9.48|
                  |L9.40|
;;;53         }
;;;54         else
;;;55         {
;;;56             //clock source is from PCLK
;;;57             SystemCoreClockUpdate();
000028  f7fffffe          BL       SystemCoreClockUpdate
;;;58             u32PWMClockSrc = SystemCoreClock;
00002c  481c              LDR      r0,|L9.160|
00002e  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
                  |L9.48|
;;;59         }
;;;60     
;;;61         u32PWMClockSrc /= 1000;
000030  217d              MOVS     r1,#0x7d
000032  00c9              LSLS     r1,r1,#3
000034  f7fffffe          BL       __aeabi_uidivmod
;;;62         for(u16Prescale = 1; u16Prescale <= 0x1000; u16Prescale++)
;;;63         {
;;;64             u32NearestUnitTimeNsec = (1000000 * u16Prescale) / u32PWMClockSrc;
;;;65             if(u32NearestUnitTimeNsec < u32UnitTimeNsec)
;;;66             {
;;;67                 if(u16Prescale == 0x1000)  //limit to the maximum unit time(nano second)
000038  2601              MOVS     r6,#1
00003a  4607              MOV      r7,r0                 ;61
00003c  0336              LSLS     r6,r6,#12
                  |L9.62|
00003e  4919              LDR      r1,|L9.164|
000040  4620              MOV      r0,r4                 ;64
000042  4348              MULS     r0,r1,r0              ;64
000044  4639              MOV      r1,r7                 ;64
000046  f7fffffe          BL       __aeabi_uidivmod
00004a  9903              LDR      r1,[sp,#0xc]          ;65
00004c  4288              CMP      r0,r1                 ;65
00004e  d20c              BCS      |L9.106|
000050  42b4              CMP      r4,r6
000052  d00a              BEQ      |L9.106|
;;;68                     break;
;;;69                 if(!((1000000 * (u16Prescale + 1) > (u32NearestUnitTimeNsec * u32PWMClockSrc))))
000054  1c61              ADDS     r1,r4,#1
000056  4b13              LDR      r3,|L9.164|
000058  460a              MOV      r2,r1
00005a  435a              MULS     r2,r3,r2
00005c  4603              MOV      r3,r0
00005e  437b              MULS     r3,r7,r3
000060  429a              CMP      r2,r3
000062  d902              BLS      |L9.106|
000064  b28c              UXTH     r4,r1                 ;62
000066  42b4              CMP      r4,r6                 ;62
000068  d9e9              BLS      |L9.62|
                  |L9.106|
;;;70                     break;
;;;71                 continue;
;;;72             }
;;;73             break;
;;;74         }
;;;75     
;;;76         // convert to real register value
;;;77         // every two channels share a prescaler
;;;78         PWM_SET_PRESCALER(pwm, u32ChannelNum, --u16Prescale);
00006a  9902              LDR      r1,[sp,#8]
00006c  1e64              SUBS     r4,r4,#1              ;62
00006e  084a              LSRS     r2,r1,#1
000070  b2a3              UXTH     r3,r4
000072  0091              LSLS     r1,r2,#2
000074  194c              ADDS     r4,r1,r5
000076  6163              STR      r3,[r4,#0x14]
;;;79     
;;;80         // set PWM to down count type(edge aligned)
;;;81         (pwm)->CTL1 = ((pwm)->CTL1 & ~(PWM_CTL1_CNTTYPE0_Msk << ((u32ChannelNum >> 1) << 2))) | (1UL << ((u32ChannelNum >> 1) << 2));
000078  686b              LDR      r3,[r5,#4]
00007a  2403              MOVS     r4,#3
00007c  408c              LSLS     r4,r4,r1
00007e  43a3              BICS     r3,r3,r4
000080  2401              MOVS     r4,#1
000082  408c              LSLS     r4,r4,r1
000084  4323              ORRS     r3,r3,r4
000086  606b              STR      r3,[r5,#4]
;;;82     
;;;83         PWM_SET_CNR(pwm, u32ChannelNum, u16CNR);
000088  00d2              LSLS     r2,r2,#3
00008a  1952              ADDS     r2,r2,r5
00008c  9900              LDR      r1,[sp,#0]
00008e  6311              STR      r1,[r2,#0x30]
;;;84     
;;;85         return (u32NearestUnitTimeNsec);
;;;86     }
000090  b005              ADD      sp,sp,#0x14
000092  bdf0              POP      {r4-r7,pc}
;;;87     
                          ENDP

                  |L9.148|
                          DCD      0x0000ffff
                  |L9.152|
                          DCD      0x40040000
                  |L9.156|
                          DCD      0x50000200
                  |L9.160|
                          DCD      SystemCoreClock
                  |L9.164|
                          DCD      0x000f4240

                          AREA ||i.PWM_ConfigOutputChannel||, CODE, READONLY, ALIGN=2

                  PWM_ConfigOutputChannel PROC
;;;99      */
;;;100    uint32_t PWM_ConfigOutputChannel(PWM_T *pwm, uint32_t u32ChannelNum, uint32_t u32Frequency, uint32_t u32DutyCycle)
000000  b5ff              PUSH     {r0-r7,lr}
;;;101    {
000002  4604              MOV      r4,r0
;;;102        uint32_t u32Src;
;;;103        uint32_t u32PWMClockSrc;
;;;104        uint32_t i;
;;;105        uint16_t u16Prescale = 1, u16CNR = 0xFFFF;
;;;106    
;;;107        if(pwm == PWM0)
;;;108            u32Src = CLK->CLKSEL3 & CLK_CLKSEL3_PWM0_S_Msk;
000004  483e              LDR      r0,|L10.256|
000006  493d              LDR      r1,|L10.252|
000008  2501              MOVS     r5,#1                 ;105
00000a  4e3b              LDR      r6,|L10.248|
;;;109        else//(pwm == PWM1)
;;;110            u32Src = CLK->CLKSEL3 & CLK_CLKSEL3_PWM1_S_Msk;
00000c  6b40              LDR      r0,[r0,#0x34]
00000e  b083              SUB      sp,sp,#0xc            ;101
000010  428c              CMP      r4,r1                 ;107
000012  d101              BNE      |L10.24|
000014  0429              LSLS     r1,r5,#16             ;108
000016  e001              B        |L10.28|
                  |L10.24|
000018  2101              MOVS     r1,#1
00001a  0449              LSLS     r1,r1,#17
                  |L10.28|
00001c  4208              TST      r0,r1
00001e  d103              BNE      |L10.40|
;;;111    
;;;112        if(u32Src == 0)
;;;113        {
;;;114            //clock source is from PLL clock
;;;115            u32PWMClockSrc = CLK_GetPLLClockFreq();
000020  f7fffffe          BL       CLK_GetPLLClockFreq
000024  4607              MOV      r7,r0
000026  e003              B        |L10.48|
                  |L10.40|
;;;116        }
;;;117        else
;;;118        {
;;;119            //clock source is from PCLK
;;;120            SystemCoreClockUpdate();
000028  f7fffffe          BL       SystemCoreClockUpdate
;;;121            u32PWMClockSrc = SystemCoreClock;
00002c  4835              LDR      r0,|L10.260|
00002e  6807              LDR      r7,[r0,#0]  ; SystemCoreClock
                  |L10.48|
;;;122        }
;;;123    
;;;124        for(u16Prescale = 1; u16Prescale < 0xFFF; u16Prescale++)//prescale could be 0~0xFFF
;;;125        {
;;;126            i = (u32PWMClockSrc / u32Frequency) / u16Prescale;
000030  9905              LDR      r1,[sp,#0x14]
000032  4638              MOV      r0,r7                 ;103
000034  f7fffffe          BL       __aeabi_uidivmod
000038  9000              STR      r0,[sp,#0]
                  |L10.58|
00003a  4629              MOV      r1,r5
00003c  f7fffffe          BL       __aeabi_uidivmod
;;;127            // If target value is larger than CNR, need to use a larger prescaler
;;;128            if(i > (0x10000))
000040  2101              MOVS     r1,#1
000042  0409              LSLS     r1,r1,#16
000044  4288              CMP      r0,r1
000046  d801              BHI      |L10.76|
;;;129                continue;
;;;130    
;;;131            u16CNR = i;
000048  b286              UXTH     r6,r0
;;;132            break;
00004a  e006              B        |L10.90|
                  |L10.76|
00004c  1c6d              ADDS     r5,r5,#1
00004e  482e              LDR      r0,|L10.264|
000050  b2ad              UXTH     r5,r5                 ;124
000052  4285              CMP      r5,r0                 ;124
000054  d201              BCS      |L10.90|
000056  9800              LDR      r0,[sp,#0]            ;124
000058  e7ef              B        |L10.58|
                  |L10.90|
;;;133        }
;;;134        // Store return value here 'cos we're gonna change u16Prescale & u16CNR to the real value to fill into register
;;;135        i = u32PWMClockSrc / (u16Prescale * u16CNR);
00005a  4629              MOV      r1,r5
00005c  4371              MULS     r1,r6,r1
00005e  4638              MOV      r0,r7
000060  f7fffffe          BL       __aeabi_uidivmod
;;;136    
;;;137        // convert to real register value
;;;138        // every two channels share a prescaler
;;;139        PWM_SET_PRESCALER(pwm, u32ChannelNum, --u16Prescale);
000064  9001              STR      r0,[sp,#4]
000066  9804              LDR      r0,[sp,#0x10]
000068  1e6d              SUBS     r5,r5,#1              ;135
00006a  0842              LSRS     r2,r0,#1
00006c  0090              LSLS     r0,r2,#2
00006e  b2a9              UXTH     r1,r5
000070  1903              ADDS     r3,r0,r4
000072  6159              STR      r1,[r3,#0x14]
;;;140        // set PWM to down count type(edge aligned)
;;;141        (pwm)->CTL1 = ((pwm)->CTL1 & ~(PWM_CTL1_CNTTYPE0_Msk << ((u32ChannelNum >> 1) << 2))) | (1UL << ((u32ChannelNum >> 1) << 2));
000074  6861              LDR      r1,[r4,#4]
000076  2303              MOVS     r3,#3
000078  4083              LSLS     r3,r3,r0
00007a  4399              BICS     r1,r1,r3
00007c  2301              MOVS     r3,#1
00007e  4083              LSLS     r3,r3,r0
000080  4319              ORRS     r1,r1,r3
000082  6061              STR      r1,[r4,#4]
000084  1e76              SUBS     r6,r6,#1
;;;142    
;;;143        PWM_SET_CNR(pwm, u32ChannelNum, --u16CNR);
000086  00d0              LSLS     r0,r2,#3
000088  b2b1              UXTH     r1,r6
00008a  1900              ADDS     r0,r0,r4
00008c  6301              STR      r1,[r0,#0x30]
;;;144        if(u32DutyCycle)
;;;145        {
;;;146            PWM_SET_CMR(pwm, u32ChannelNum, u32DutyCycle * (u16CNR + 1) / 100 - 1);
00008e  9804              LDR      r0,[sp,#0x10]
;;;147            (pwm)->WGCTL0 &= ~((PWM_WGCTL0_PRDPCTL0_Msk | PWM_WGCTL0_ZPCTL0_Msk) << (u32ChannelNum * 2));
000090  4d1e              LDR      r5,|L10.268|
000092  0080              LSLS     r0,r0,#2              ;146
000094  1907              ADDS     r7,r0,r4              ;146
000096  9804              LDR      r0,[sp,#0x10]
;;;148            (pwm)->WGCTL0 |= (PWM_OUTPUT_LOW << (u32ChannelNum * 2 + PWM_WGCTL0_PRDPCTL0_Pos));
;;;149            (pwm)->WGCTL1 &= ~((PWM_WGCTL1_CMPDCTL0_Msk | PWM_WGCTL1_CMPUCTL0_Msk) << (u32ChannelNum * 2));
;;;150            (pwm)->WGCTL1 |= (PWM_OUTPUT_HIGH << (u32ChannelNum * 2 + PWM_WGCTL1_CMPDCTL0_Pos));
000098  2602              MOVS     r6,#2
00009a  0040              LSLS     r0,r0,#1              ;147
00009c  4603              MOV      r3,r0                 ;148
00009e  3310              ADDS     r3,r3,#0x10           ;148
0000a0  409e              LSLS     r6,r6,r3
0000a2  9a06              LDR      r2,[sp,#0x18]         ;148
0000a4  4085              LSLS     r5,r5,r0              ;147
0000a6  3480              ADDS     r4,r4,#0x80           ;147
0000a8  9300              STR      r3,[sp,#0]            ;144
0000aa  2a00              CMP      r2,#0                 ;144
0000ac  d011              BEQ      |L10.210|
0000ae  4610              MOV      r0,r2                 ;146
0000b0  1c49              ADDS     r1,r1,#1              ;146
0000b2  4348              MULS     r0,r1,r0              ;146
0000b4  2164              MOVS     r1,#0x64              ;146
0000b6  f7fffffe          BL       __aeabi_uidivmod
0000ba  1e40              SUBS     r0,r0,#1              ;146
0000bc  6538              STR      r0,[r7,#0x50]         ;146
0000be  6b20              LDR      r0,[r4,#0x30]         ;147
0000c0  43a8              BICS     r0,r0,r5              ;147
0000c2  6320              STR      r0,[r4,#0x30]         ;147
0000c4  6b21              LDR      r1,[r4,#0x30]         ;148
0000c6  9a00              LDR      r2,[sp,#0]            ;148
0000c8  2001              MOVS     r0,#1                 ;148
0000ca  4090              LSLS     r0,r0,r2              ;148
0000cc  4301              ORRS     r1,r1,r0              ;148
0000ce  6321              STR      r1,[r4,#0x30]         ;148
0000d0  e009              B        |L10.230|
                  |L10.210|
;;;151        }
;;;152        else
;;;153        {
;;;154            PWM_SET_CMR(pwm, u32ChannelNum, 0);
0000d2  2100              MOVS     r1,#0
0000d4  6539              STR      r1,[r7,#0x50]
;;;155            (pwm)->WGCTL0 &= ~((PWM_WGCTL0_PRDPCTL0_Msk | PWM_WGCTL0_ZPCTL0_Msk) << (u32ChannelNum * 2));
0000d6  6b21              LDR      r1,[r4,#0x30]
0000d8  43a9              BICS     r1,r1,r5
0000da  6321              STR      r1,[r4,#0x30]
;;;156            (pwm)->WGCTL0 |= (PWM_OUTPUT_LOW << (u32ChannelNum * 2 + PWM_WGCTL0_ZPCTL0_Pos));
0000dc  6b22              LDR      r2,[r4,#0x30]
0000de  2101              MOVS     r1,#1
0000e0  4081              LSLS     r1,r1,r0
0000e2  430a              ORRS     r2,r2,r1
0000e4  6322              STR      r2,[r4,#0x30]
                  |L10.230|
;;;157            (pwm)->WGCTL1 &= ~((PWM_WGCTL1_CMPDCTL0_Msk | PWM_WGCTL1_CMPUCTL0_Msk) << (u32ChannelNum * 2));
0000e6  6b60              LDR      r0,[r4,#0x34]
0000e8  43a8              BICS     r0,r0,r5
0000ea  6360              STR      r0,[r4,#0x34]
;;;158            (pwm)->WGCTL1 |= (PWM_OUTPUT_HIGH << (u32ChannelNum * 2 + PWM_WGCTL1_CMPDCTL0_Pos));
0000ec  6b60              LDR      r0,[r4,#0x34]
0000ee  4330              ORRS     r0,r0,r6
0000f0  6360              STR      r0,[r4,#0x34]
;;;159        }
;;;160    
;;;161        return(i);
0000f2  9801              LDR      r0,[sp,#4]
;;;162    }
0000f4  b007              ADD      sp,sp,#0x1c
0000f6  bdf0              POP      {r4-r7,pc}
;;;163    
                          ENDP

                  |L10.248|
                          DCD      0x0000ffff
                  |L10.252|
                          DCD      0x40040000
                  |L10.256|
                          DCD      0x50000200
                  |L10.260|
                          DCD      SystemCoreClock
                  |L10.264|
                          DCD      0x00000fff
                  |L10.268|
                          DCD      0x00030003

                          AREA ||i.PWM_DisableADCTrigger||, CODE, READONLY, ALIGN=1

                  PWM_DisableADCTrigger PROC
;;;269     */
;;;270    void PWM_DisableADCTrigger(PWM_T *pwm, uint32_t u32ChannelNum)
000000  00ca              LSLS     r2,r1,#3
;;;271    {
;;;272        if(u32ChannelNum < 4)
;;;273        {
;;;274            (pwm)->ADCTS0 &= ~(PWM_ADCTS0_TRGEN0_Msk << (u32ChannelNum * 8));
000002  2380              MOVS     r3,#0x80
000004  3080              ADDS     r0,r0,#0x80
000006  2904              CMP      r1,#4                 ;272
000008  d204              BCS      |L11.20|
00000a  6f81              LDR      r1,[r0,#0x78]
00000c  4093              LSLS     r3,r3,r2
00000e  4399              BICS     r1,r1,r3
000010  6781              STR      r1,[r0,#0x78]
;;;275        }
;;;276        else
;;;277        {
;;;278            (pwm)->ADCTS1 &= ~(PWM_ADCTS1_TRGEN4_Msk << ((u32ChannelNum - 4) * 8));
;;;279        }
;;;280    }
000012  4770              BX       lr
                  |L11.20|
000014  3a20              SUBS     r2,r2,#0x20
000016  6fc1              LDR      r1,[r0,#0x7c]         ;278
000018  4093              LSLS     r3,r3,r2              ;278
00001a  4399              BICS     r1,r1,r3              ;278
00001c  67c1              STR      r1,[r0,#0x7c]         ;278
00001e  4770              BX       lr
;;;281    
                          ENDP


                          AREA ||i.PWM_DisableBrakeNoiseFilter||, CODE, READONLY, ALIGN=1

                  PWM_DisableBrakeNoiseFilter PROC
;;;887     */
;;;888    void PWM_DisableBrakeNoiseFilter(PWM_T *pwm, uint32_t u32BrakePinNum)
000000  3080              ADDS     r0,r0,#0x80
;;;889    {
;;;890        (pwm)->BNF &= ~(PWM_BNF_BRK0NFEN_Msk << (u32BrakePinNum * PWM_BNF_BRK1NFEN_Pos));
000002  6c02              LDR      r2,[r0,#0x40]
000004  00cb              LSLS     r3,r1,#3
000006  2101              MOVS     r1,#1
000008  4099              LSLS     r1,r1,r3
00000a  438a              BICS     r2,r2,r1
00000c  6402              STR      r2,[r0,#0x40]
;;;891    }
00000e  4770              BX       lr
;;;892    
                          ENDP


                          AREA ||i.PWM_DisableBrakePinInverse||, CODE, READONLY, ALIGN=1

                  PWM_DisableBrakePinInverse PROC
;;;915     */
;;;916    void PWM_DisableBrakePinInverse(PWM_T *pwm, uint32_t u32BrakePinNum)
000000  3080              ADDS     r0,r0,#0x80
;;;917    {
;;;918        (pwm)->BNF &= ~(PWM_BNF_BRK0PINV_Msk << (u32BrakePinNum * PWM_BNF_BRK1NFEN_Pos));
000002  6c02              LDR      r2,[r0,#0x40]
000004  00cb              LSLS     r3,r1,#3
000006  2180              MOVS     r1,#0x80
000008  4099              LSLS     r1,r1,r3
00000a  438a              BICS     r2,r2,r1
00000c  6402              STR      r2,[r0,#0x40]
;;;919    }
00000e  4770              BX       lr
;;;920    
                          ENDP


                          AREA ||i.PWM_DisableCapture||, CODE, READONLY, ALIGN=1

                  PWM_DisableCapture PROC
;;;417     */
;;;418    void PWM_DisableCapture(PWM_T *pwm, uint32_t u32ChannelMask)
000000  30ff              ADDS     r0,r0,#0xff
;;;419    {
000002  30ff              ADDS     r0,r0,#0xff
000004  3002              ADDS     r0,#2
;;;420        (pwm)->CAPINEN &= ~u32ChannelMask;
000006  6802              LDR      r2,[r0,#0]
000008  438a              BICS     r2,r2,r1
00000a  6002              STR      r2,[r0,#0]
;;;421        (pwm)->CAPCTL &= ~u32ChannelMask;
00000c  6842              LDR      r2,[r0,#4]
00000e  438a              BICS     r2,r2,r1
000010  6042              STR      r2,[r0,#4]
;;;422    }
000012  4770              BX       lr
;;;423    
                          ENDP


                          AREA ||i.PWM_DisableCaptureInt||, CODE, READONLY, ALIGN=1

                  PWM_DisableCaptureInt PROC
;;;517     */
;;;518    void PWM_DisableCaptureInt(PWM_T *pwm, uint32_t u32ChannelNum, uint32_t u32Edge)
000000  30ff              ADDS     r0,r0,#0xff
;;;519    {
000002  30ff              ADDS     r0,r0,#0xff
000004  3002              ADDS     r0,#2
;;;520        (pwm)->CAPIEN &= ~(u32Edge << u32ChannelNum);
000006  6d03              LDR      r3,[r0,#0x50]
000008  408a              LSLS     r2,r2,r1
00000a  4393              BICS     r3,r3,r2
00000c  6503              STR      r3,[r0,#0x50]
;;;521    }
00000e  4770              BX       lr
;;;522    
                          ENDP


                          AREA ||i.PWM_DisableDeadZone||, CODE, READONLY, ALIGN=1

                  PWM_DisableDeadZone PROC
;;;482     */
;;;483    void PWM_DisableDeadZone(PWM_T *pwm, uint32_t u32ChannelNum)
000000  0849              LSRS     r1,r1,#1
;;;484    {
;;;485        // every two channels shares the same setting
;;;486        *(__IO uint32_t *)(&((pwm)->DTCTL0_1) + (u32ChannelNum >> 1)) &= ~PWM_DTCTL0_1_DTEN_Msk;
000002  0089              LSLS     r1,r1,#2
000004  1808              ADDS     r0,r1,r0
000006  6f01              LDR      r1,[r0,#0x70]
000008  2201              MOVS     r2,#1
00000a  0412              LSLS     r2,r2,#16
00000c  4391              BICS     r1,r1,r2
00000e  6701              STR      r1,[r0,#0x70]
;;;487    }
000010  4770              BX       lr
;;;488    
                          ENDP


                          AREA ||i.PWM_DisableDutyInt||, CODE, READONLY, ALIGN=2

                  PWM_DisableDutyInt PROC
;;;582     */
;;;583    void PWM_DisableDutyInt(PWM_T *pwm, uint32_t u32ChannelNum)
000000  3080              ADDS     r0,r0,#0x80
;;;584    {
;;;585        (pwm)->INTEN0 &= ~((PWM_DUTY_INT_DOWN_COUNT_MATCH_CMP | PWM_DUTY_INT_UP_COUNT_MATCH_CMP) << u32ChannelNum);
000002  6e02              LDR      r2,[r0,#0x60]
000004  4b02              LDR      r3,|L17.16|
000006  408b              LSLS     r3,r3,r1
000008  439a              BICS     r2,r2,r3
00000a  6602              STR      r2,[r0,#0x60]
;;;586    }
00000c  4770              BX       lr
;;;587    
                          ENDP

00000e  0000              DCW      0x0000
                  |L17.16|
                          DCD      0x01010000

                          AREA ||i.PWM_DisableFaultBrakeInt||, CODE, READONLY, ALIGN=1

                  PWM_DisableFaultBrakeInt PROC
;;;678     */
;;;679    void PWM_DisableFaultBrakeInt(PWM_T *pwm, uint32_t u32BrakeSource)
000000  3080              ADDS     r0,r0,#0x80
;;;680    {
;;;681        (pwm)->INTEN1 &= ~(0x7 << u32BrakeSource);
000002  6e42              LDR      r2,[r0,#0x64]
000004  2307              MOVS     r3,#7
000006  408b              LSLS     r3,r3,r1
000008  439a              BICS     r2,r2,r3
00000a  6642              STR      r2,[r0,#0x64]
;;;682    }
00000c  4770              BX       lr
;;;683    
                          ENDP


                          AREA ||i.PWM_DisableLoadMode||, CODE, READONLY, ALIGN=1

                  PWM_DisableLoadMode PROC
;;;646     */
;;;647    void PWM_DisableLoadMode(PWM_T *pwm, uint32_t u32ChannelNum, uint32_t u32LoadMode)
000000  6803              LDR      r3,[r0,#0]
;;;648    {
;;;649        (pwm)->CTL0 &= ~(u32LoadMode << u32ChannelNum);
000002  408a              LSLS     r2,r2,r1
000004  4393              BICS     r3,r3,r2
000006  6003              STR      r3,[r0,#0]
;;;650    }
000008  4770              BX       lr
;;;651    
                          ENDP


                          AREA ||i.PWM_DisableOutput||, CODE, READONLY, ALIGN=1

                  PWM_DisableOutput PROC
;;;448     */
;;;449    void PWM_DisableOutput(PWM_T *pwm, uint32_t u32ChannelMask)
000000  3080              ADDS     r0,r0,#0x80
;;;450    {
;;;451        (pwm)->POEN &= ~u32ChannelMask;
000002  6d82              LDR      r2,[r0,#0x58]
000004  438a              BICS     r2,r2,r1
000006  6582              STR      r2,[r0,#0x58]
;;;452    }
000008  4770              BX       lr
;;;453    
                          ENDP


                          AREA ||i.PWM_DisablePeriodInt||, CODE, READONLY, ALIGN=1

                  PWM_DisablePeriodInt PROC
;;;738     */
;;;739    void PWM_DisablePeriodInt(PWM_T *pwm, uint32_t u32ChannelNum)
000000  3080              ADDS     r0,r0,#0x80
;;;740    {
;;;741        (pwm)->INTEN0 &= ~(PWM_INTEN0_PIEN0_Msk << ((u32ChannelNum >> 1) << 1));
000002  6e02              LDR      r2,[r0,#0x60]
000004  084b              LSRS     r3,r1,#1
000006  005b              LSLS     r3,r3,#1
000008  21ff              MOVS     r1,#0xff
00000a  3101              ADDS     r1,#1
00000c  4099              LSLS     r1,r1,r3
00000e  438a              BICS     r2,r2,r1
000010  6602              STR      r2,[r0,#0x60]
;;;742    }
000012  4770              BX       lr
;;;743    
                          ENDP


                          AREA ||i.PWM_DisableZeroInt||, CODE, READONLY, ALIGN=1

                  PWM_DisableZeroInt PROC
;;;796     */
;;;797    void PWM_DisableZeroInt(PWM_T *pwm, uint32_t u32ChannelNum)
000000  3080              ADDS     r0,r0,#0x80
;;;798    {
;;;799        (pwm)->INTEN0 &= ~(PWM_INTEN0_ZIEN0_Msk << ((u32ChannelNum >> 1) << 1));
000002  6e02              LDR      r2,[r0,#0x60]
000004  084b              LSRS     r3,r1,#1
000006  005b              LSLS     r3,r3,#1
000008  2101              MOVS     r1,#1
00000a  4099              LSLS     r1,r1,r3
00000c  438a              BICS     r2,r2,r1
00000e  6602              STR      r2,[r0,#0x60]
;;;800    }
000010  4770              BX       lr
;;;801    
                          ENDP


                          AREA ||i.PWM_EnableADCTrigger||, CODE, READONLY, ALIGN=1

                  PWM_EnableADCTrigger PROC
;;;246     */
;;;247    void PWM_EnableADCTrigger(PWM_T *pwm, uint32_t u32ChannelNum, uint32_t u32Condition)
000000  b510              PUSH     {r4,lr}
;;;248    {
;;;249        if(u32ChannelNum < 4)
;;;250        {
;;;251            (pwm)->ADCTS0 &= ~((PWM_ADCTS0_TRGSEL0_Msk) << (u32ChannelNum * 8));
;;;252            (pwm)->ADCTS0 |= ((PWM_ADCTS0_TRGEN0_Msk | u32Condition) << (u32ChannelNum * 8));
000002  2380              MOVS     r3,#0x80
000004  431a              ORRS     r2,r2,r3
000006  240f              MOVS     r4,#0xf               ;251
000008  00cb              LSLS     r3,r1,#3              ;251
00000a  3080              ADDS     r0,r0,#0x80           ;251
00000c  2904              CMP      r1,#4                 ;249
00000e  d208              BCS      |L23.34|
000010  6f81              LDR      r1,[r0,#0x78]         ;251
000012  409c              LSLS     r4,r4,r3              ;251
000014  43a1              BICS     r1,r1,r4              ;251
000016  6781              STR      r1,[r0,#0x78]         ;251
000018  6f81              LDR      r1,[r0,#0x78]
00001a  409a              LSLS     r2,r2,r3
00001c  430a              ORRS     r2,r2,r1
00001e  6782              STR      r2,[r0,#0x78]
;;;253        }
;;;254        else
;;;255        {
;;;256            (pwm)->ADCTS1 &= ~((PWM_ADCTS1_TRGSEL4_Msk) << ((u32ChannelNum - 4) * 8));
;;;257            (pwm)->ADCTS1 |= ((PWM_ADCTS1_TRGEN4_Msk | u32Condition) << ((u32ChannelNum - 4) * 8));
;;;258        }
;;;259    }
000020  bd10              POP      {r4,pc}
                  |L23.34|
000022  3b20              SUBS     r3,r3,#0x20
000024  6fc1              LDR      r1,[r0,#0x7c]         ;256
000026  409c              LSLS     r4,r4,r3              ;256
000028  43a1              BICS     r1,r1,r4              ;256
00002a  67c1              STR      r1,[r0,#0x7c]         ;256
00002c  6fc1              LDR      r1,[r0,#0x7c]         ;257
00002e  409a              LSLS     r2,r2,r3              ;257
000030  430a              ORRS     r2,r2,r1              ;257
000032  67c2              STR      r2,[r0,#0x7c]         ;257
000034  bd10              POP      {r4,pc}
;;;260    
                          ENDP


                          AREA ||i.PWM_EnableBrakeNoiseFilter||, CODE, READONLY, ALIGN=1

                  PWM_EnableBrakeNoiseFilter PROC
;;;872     */
;;;873    void PWM_EnableBrakeNoiseFilter(PWM_T *pwm, uint32_t u32BrakePinNum, uint32_t u32ClkCnt, uint32_t u32ClkDivSel)
000000  b530              PUSH     {r4,r5,lr}
;;;874    {
000002  3080              ADDS     r0,r0,#0x80
;;;875        (pwm)->BNF = ((pwm)->BNF & ~((PWM_BNF_BRK0FCNT_Msk | PWM_BNF_BRK0NFSEL_Msk) << (u32BrakePinNum * PWM_BNF_BRK1NFEN_Pos))) | \
000004  6c04              LDR      r4,[r0,#0x40]
000006  00c9              LSLS     r1,r1,#3
000008  257e              MOVS     r5,#0x7e
00000a  408d              LSLS     r5,r5,r1
00000c  0112              LSLS     r2,r2,#4
00000e  005b              LSLS     r3,r3,#1
000010  431a              ORRS     r2,r2,r3
000012  1c52              ADDS     r2,r2,#1
000014  43ac              BICS     r4,r4,r5
000016  408a              LSLS     r2,r2,r1
000018  4314              ORRS     r4,r4,r2
00001a  6404              STR      r4,[r0,#0x40]
;;;876                     (((u32ClkCnt << PWM_BNF_BRK0FCNT_Pos) | (u32ClkDivSel << PWM_BNF_BRK0NFSEL_Pos) | PWM_BNF_BRK0NFEN_Msk) << (u32BrakePinNum * PWM_BNF_BRK1NFEN_Pos));
;;;877    }
00001c  bd30              POP      {r4,r5,pc}
;;;878    
                          ENDP


                          AREA ||i.PWM_EnableBrakePinInverse||, CODE, READONLY, ALIGN=1

                  PWM_EnableBrakePinInverse PROC
;;;901     */
;;;902    void PWM_EnableBrakePinInverse(PWM_T *pwm, uint32_t u32BrakePinNum)
000000  3080              ADDS     r0,r0,#0x80
;;;903    {
;;;904        (pwm)->BNF |= (PWM_BNF_BRK0PINV_Msk << (u32BrakePinNum * PWM_BNF_BRK1NFEN_Pos));
000002  6c02              LDR      r2,[r0,#0x40]
000004  00cb              LSLS     r3,r1,#3
000006  2180              MOVS     r1,#0x80
000008  4099              LSLS     r1,r1,r3
00000a  430a              ORRS     r2,r2,r1
00000c  6402              STR      r2,[r0,#0x40]
;;;905    }
00000e  4770              BX       lr
;;;906    
                          ENDP


                          AREA ||i.PWM_EnableCapture||, CODE, READONLY, ALIGN=1

                  PWM_EnableCapture PROC
;;;401     */
;;;402    void PWM_EnableCapture(PWM_T *pwm, uint32_t u32ChannelMask)
000000  30ff              ADDS     r0,r0,#0xff
;;;403    {
000002  30ff              ADDS     r0,r0,#0xff
000004  3002              ADDS     r0,#2
;;;404        (pwm)->CAPINEN |= u32ChannelMask;
000006  6802              LDR      r2,[r0,#0]
000008  430a              ORRS     r2,r2,r1
00000a  6002              STR      r2,[r0,#0]
;;;405        (pwm)->CAPCTL |= u32ChannelMask;
00000c  6842              LDR      r2,[r0,#4]
00000e  430a              ORRS     r2,r2,r1
000010  6042              STR      r2,[r0,#4]
;;;406    }
000012  4770              BX       lr
;;;407    
                          ENDP


                          AREA ||i.PWM_EnableCaptureInt||, CODE, READONLY, ALIGN=1

                  PWM_EnableCaptureInt PROC
;;;500     */
;;;501    void PWM_EnableCaptureInt(PWM_T *pwm, uint32_t u32ChannelNum, uint32_t u32Edge)
000000  30ff              ADDS     r0,r0,#0xff
;;;502    {
000002  30ff              ADDS     r0,r0,#0xff
000004  3002              ADDS     r0,#2
;;;503        (pwm)->CAPIEN |= (u32Edge << u32ChannelNum);
000006  6d03              LDR      r3,[r0,#0x50]
000008  408a              LSLS     r2,r2,r1
00000a  4313              ORRS     r3,r3,r2
00000c  6503              STR      r3,[r0,#0x50]
;;;504    }
00000e  4770              BX       lr
;;;505    
                          ENDP


                          AREA ||i.PWM_EnableDeadZone||, CODE, READONLY, ALIGN=1

                  PWM_EnableDeadZone PROC
;;;465     */
;;;466    void PWM_EnableDeadZone(PWM_T *pwm, uint32_t u32ChannelNum, uint32_t u32Duration)
000000  0849              LSRS     r1,r1,#1
;;;467    {
;;;468        // every two channels share the same setting
;;;469        *(__IO uint32_t *)(&((pwm)->DTCTL0_1) + (u32ChannelNum >> 1)) &= ~PWM_DTCTL0_1_DTCNT_Msk;
000002  0089              LSLS     r1,r1,#2
000004  1808              ADDS     r0,r1,r0
000006  6f01              LDR      r1,[r0,#0x70]
000008  0b09              LSRS     r1,r1,#12
00000a  0309              LSLS     r1,r1,#12
00000c  6701              STR      r1,[r0,#0x70]
;;;470        *(__IO uint32_t *)(&((pwm)->DTCTL0_1) + (u32ChannelNum >> 1)) |= PWM_DTCTL0_1_DTEN_Msk | u32Duration;
00000e  6f01              LDR      r1,[r0,#0x70]
000010  2301              MOVS     r3,#1
000012  041b              LSLS     r3,r3,#16
000014  431a              ORRS     r2,r2,r3
000016  4311              ORRS     r1,r1,r2
000018  6701              STR      r1,[r0,#0x70]
;;;471    }
00001a  4770              BX       lr
;;;472    
                          ENDP


                          AREA ||i.PWM_EnableDutyInt||, CODE, READONLY, ALIGN=1

                  PWM_EnableDutyInt PROC
;;;568     */
;;;569    void PWM_EnableDutyInt(PWM_T *pwm, uint32_t u32ChannelNum, uint32_t u32IntDutyType)
000000  3080              ADDS     r0,r0,#0x80
;;;570    {
;;;571        (pwm)->INTEN0 |= (u32IntDutyType << u32ChannelNum);
000002  6e03              LDR      r3,[r0,#0x60]
000004  408a              LSLS     r2,r2,r1
000006  4313              ORRS     r3,r3,r2
000008  6603              STR      r3,[r0,#0x60]
;;;572    }
00000a  4770              BX       lr
;;;573    
                          ENDP


                          AREA ||i.PWM_EnableFaultBrake||, CODE, READONLY, ALIGN=2

                  PWM_EnableFaultBrake PROC
;;;336     */
;;;337    void PWM_EnableFaultBrake(PWM_T *pwm, uint32_t u32ChannelMask, uint32_t u32LevelMask, uint32_t u32BrakeSource)
000000  b5f0              PUSH     {r4-r7,lr}
;;;338    {
000002  4696              MOV      lr,r2
;;;339        uint32_t i;
;;;340        for(i = 0; i < PWM_CHANNEL_NUM; i ++)
000004  2400              MOVS     r4,#0
;;;341        {
;;;342            if(u32ChannelMask & (1 << i))
;;;343            {
;;;344                if((u32BrakeSource == PWM_FB_EDGE_SYS_CSS) || (u32BrakeSource == PWM_FB_EDGE_SYS_BOD) || \
;;;345                        (u32BrakeSource == PWM_FB_EDGE_SYS_RAM) || (u32BrakeSource == PWM_FB_EDGE_SYS_COR) || \
;;;346                        (u32BrakeSource == PWM_FB_LEVEL_SYS_CSS) || (u32BrakeSource == PWM_FB_LEVEL_SYS_BOD) || \
;;;347                        (u32BrakeSource == PWM_FB_LEVEL_SYS_RAM) || (u32BrakeSource == PWM_FB_LEVEL_SYS_COR))
;;;348                {
;;;349                    *(__IO uint32_t *)(&((pwm)->BRKCTL0_1) + (i >> 1)) |= (u32BrakeSource & (PWM_BRKCTL0_1_SYSEBEN_Msk | PWM_BRKCTL0_1_SYSLBEN_Msk));
;;;350                    (pwm)->FAILBRK |= (u32BrakeSource & 0xF);
;;;351                }
;;;352                else
;;;353                {
;;;354                    *(__IO uint32_t *)(&((pwm)->BRKCTL0_1) + (i >> 1)) |= u32BrakeSource;
;;;355                }
;;;356            }
;;;357    
;;;358            if(u32LevelMask & (1 << i))
;;;359            {
;;;360                if(i % 2 == 0)
;;;361                {
;;;362                    //set brake action as high level for even channel
;;;363                    *(__IO uint32_t *)(&((pwm)->BRKCTL0_1) + (i >> 1)) &= ~PWM_BRKCTL0_1_BRKAEVEN_Msk;
000006  2203              MOVS     r2,#3
000008  468c              MOV      r12,r1                ;338
00000a  0412              LSLS     r2,r2,#16
                  |L30.12|
00000c  2501              MOVS     r5,#1                 ;342
00000e  40a5              LSLS     r5,r5,r4              ;342
000010  4661              MOV      r1,r12                ;342
000012  420d              TST      r5,r1                 ;342
000014  d02c              BEQ      |L30.112|
000016  2b81              CMP      r3,#0x81              ;344
000018  d011              BEQ      |L30.62|
00001a  2b82              CMP      r3,#0x82              ;344
00001c  d00f              BEQ      |L30.62|
00001e  2b84              CMP      r3,#0x84              ;345
000020  d00d              BEQ      |L30.62|
000022  2b88              CMP      r3,#0x88              ;345
000024  d00b              BEQ      |L30.62|
000026  4930              LDR      r1,|L30.232|
000028  428b              CMP      r3,r1                 ;346
00002a  d008              BEQ      |L30.62|
00002c  1c49              ADDS     r1,r1,#1              ;346
00002e  428b              CMP      r3,r1                 ;346
000030  d005              BEQ      |L30.62|
000032  1c89              ADDS     r1,r1,#2              ;347
000034  428b              CMP      r3,r1                 ;347
000036  d002              BEQ      |L30.62|
000038  1d09              ADDS     r1,r1,#4              ;347
00003a  428b              CMP      r3,r1                 ;347
00003c  d111              BNE      |L30.98|
                  |L30.62|
00003e  0861              LSRS     r1,r4,#1              ;349
000040  0089              LSLS     r1,r1,#2              ;349
000042  180e              ADDS     r6,r1,r0              ;349
000044  3680              ADDS     r6,r6,#0x80           ;349
000046  6cb1              LDR      r1,[r6,#0x48]         ;349
000048  4f27              LDR      r7,|L30.232|
00004a  377f              ADDS     r7,r7,#0x7f           ;349
00004c  401f              ANDS     r7,r7,r3              ;349
00004e  4339              ORRS     r1,r1,r7              ;349
000050  64b1              STR      r1,[r6,#0x48]         ;349
000052  4606              MOV      r6,r0                 ;350
000054  3680              ADDS     r6,r6,#0x80           ;350
000056  6c77              LDR      r7,[r6,#0x44]         ;350
000058  0719              LSLS     r1,r3,#28             ;350
00005a  0f09              LSRS     r1,r1,#28             ;350
00005c  430f              ORRS     r7,r7,r1              ;350
00005e  6477              STR      r7,[r6,#0x44]         ;350
000060  e006              B        |L30.112|
                  |L30.98|
000062  0861              LSRS     r1,r4,#1              ;354
000064  0089              LSLS     r1,r1,#2              ;354
000066  1809              ADDS     r1,r1,r0              ;354
000068  3180              ADDS     r1,r1,#0x80           ;354
00006a  6c8e              LDR      r6,[r1,#0x48]         ;354
00006c  431e              ORRS     r6,r6,r3              ;354
00006e  648e              STR      r6,[r1,#0x48]         ;354
                  |L30.112|
000070  4671              MOV      r1,lr                 ;358
000072  420d              TST      r5,r1                 ;358
000074  d018              BEQ      |L30.168|
000076  07e1              LSLS     r1,r4,#31             ;360
000078  d00c              BEQ      |L30.148|
;;;364                    *(__IO uint32_t *)(&((pwm)->BRKCTL0_1) + (i >> 1)) |= ((3UL) << PWM_BRKCTL0_1_BRKAEVEN_Pos);
;;;365                }
;;;366                else
;;;367                {
;;;368                    //set brake action as high level for odd channel
;;;369                    *(__IO uint32_t *)(&((pwm)->BRKCTL0_1) + (i >> 1)) &= ~PWM_BRKCTL0_1_BRKAODD_Msk;
00007a  0861              LSRS     r1,r4,#1
00007c  0089              LSLS     r1,r1,#2
00007e  180d              ADDS     r5,r1,r0
000080  3580              ADDS     r5,r5,#0x80
000082  6caf              LDR      r7,[r5,#0x48]
000084  2603              MOVS     r6,#3
000086  04b6              LSLS     r6,r6,#18
000088  43b7              BICS     r7,r7,r6
00008a  64af              STR      r7,[r5,#0x48]
;;;370                    *(__IO uint32_t *)(&((pwm)->BRKCTL0_1) + (i >> 1)) |= ((3UL) << PWM_BRKCTL0_1_BRKAODD_Pos);
00008c  6ca9              LDR      r1,[r5,#0x48]
00008e  4331              ORRS     r1,r1,r6
000090  64a9              STR      r1,[r5,#0x48]
000092  e019              B        |L30.200|
                  |L30.148|
000094  0861              LSRS     r1,r4,#1              ;363
000096  0089              LSLS     r1,r1,#2              ;363
000098  1809              ADDS     r1,r1,r0              ;363
00009a  3180              ADDS     r1,r1,#0x80           ;363
00009c  6c8d              LDR      r5,[r1,#0x48]         ;363
00009e  4395              BICS     r5,r5,r2              ;363
0000a0  648d              STR      r5,[r1,#0x48]         ;363
0000a2  6c8d              LDR      r5,[r1,#0x48]         ;364
0000a4  4315              ORRS     r5,r5,r2              ;364
0000a6  e00e              B        |L30.198|
                  |L30.168|
;;;371                }
;;;372            }
;;;373            else
;;;374            {
;;;375                if(i % 2 == 0)
0000a8  07e1              LSLS     r1,r4,#31
0000aa  d011              BEQ      |L30.208|
;;;376                {
;;;377                    //set brake action as low level for even channel
;;;378                    *(__IO uint32_t *)(&((pwm)->BRKCTL0_1) + (i >> 1)) &= ~PWM_BRKCTL0_1_BRKAEVEN_Msk;
;;;379                    *(__IO uint32_t *)(&((pwm)->BRKCTL0_1) + (i >> 1)) |= ((2UL) << PWM_BRKCTL0_1_BRKAEVEN_Pos);
;;;380                }
;;;381                else
;;;382                {
;;;383                    //set brake action as low level for odd channel
;;;384                    *(__IO uint32_t *)(&((pwm)->BRKCTL0_1) + (i >> 1)) &= ~PWM_BRKCTL0_1_BRKAODD_Msk;
0000ac  0861              LSRS     r1,r4,#1
0000ae  0089              LSLS     r1,r1,#2
0000b0  1809              ADDS     r1,r1,r0
0000b2  3180              ADDS     r1,r1,#0x80
0000b4  6c8d              LDR      r5,[r1,#0x48]
0000b6  2603              MOVS     r6,#3
0000b8  04b6              LSLS     r6,r6,#18
0000ba  43b5              BICS     r5,r5,r6
0000bc  648d              STR      r5,[r1,#0x48]
;;;385                    *(__IO uint32_t *)(&((pwm)->BRKCTL0_1) + (i >> 1)) |= ((2UL) << PWM_BRKCTL0_1_BRKAODD_Pos);
0000be  6c8d              LDR      r5,[r1,#0x48]
0000c0  2601              MOVS     r6,#1
0000c2  04f6              LSLS     r6,r6,#19
                  |L30.196|
0000c4  4335              ORRS     r5,r5,r6              ;379
                  |L30.198|
0000c6  648d              STR      r5,[r1,#0x48]         ;379
                  |L30.200|
0000c8  1c64              ADDS     r4,r4,#1              ;379
0000ca  2c06              CMP      r4,#6                 ;340
0000cc  d39e              BCC      |L30.12|
;;;386                }
;;;387            }
;;;388        }
;;;389    
;;;390    }
0000ce  bdf0              POP      {r4-r7,pc}
                  |L30.208|
0000d0  0861              LSRS     r1,r4,#1              ;378
0000d2  0089              LSLS     r1,r1,#2              ;378
0000d4  1809              ADDS     r1,r1,r0              ;378
0000d6  3180              ADDS     r1,r1,#0x80           ;378
0000d8  6c8d              LDR      r5,[r1,#0x48]         ;378
0000da  4395              BICS     r5,r5,r2              ;378
0000dc  648d              STR      r5,[r1,#0x48]         ;378
0000de  6c8d              LDR      r5,[r1,#0x48]         ;379
0000e0  2601              MOVS     r6,#1                 ;379
0000e2  0476              LSLS     r6,r6,#17             ;379
0000e4  e7ee              B        |L30.196|
;;;391    
                          ENDP

0000e6  0000              DCW      0x0000
                  |L30.232|
                          DCD      0x00008001

                          AREA ||i.PWM_EnableFaultBrakeInt||, CODE, READONLY, ALIGN=1

                  PWM_EnableFaultBrakeInt PROC
;;;662     */
;;;663    void PWM_EnableFaultBrakeInt(PWM_T *pwm, uint32_t u32BrakeSource)
000000  3080              ADDS     r0,r0,#0x80
;;;664    {
;;;665        (pwm)->INTEN1 |= (0x7 << u32BrakeSource);
000002  6e42              LDR      r2,[r0,#0x64]
000004  2307              MOVS     r3,#7
000006  408b              LSLS     r3,r3,r1
000008  431a              ORRS     r2,r2,r3
00000a  6642              STR      r2,[r0,#0x64]
;;;666    }
00000c  4770              BX       lr
;;;667    
                          ENDP


                          AREA ||i.PWM_EnableLoadMode||, CODE, READONLY, ALIGN=1

                  PWM_EnableLoadMode PROC
;;;629     */
;;;630    void PWM_EnableLoadMode(PWM_T *pwm, uint32_t u32ChannelNum, uint32_t u32LoadMode)
000000  6803              LDR      r3,[r0,#0]
;;;631    {
;;;632        (pwm)->CTL0 |= (u32LoadMode << u32ChannelNum);
000002  408a              LSLS     r2,r2,r1
000004  4313              ORRS     r3,r3,r2
000006  6003              STR      r3,[r0,#0]
;;;633    }
000008  4770              BX       lr
;;;634    
                          ENDP


                          AREA ||i.PWM_EnableOutput||, CODE, READONLY, ALIGN=1

                  PWM_EnableOutput PROC
;;;433     */
;;;434    void PWM_EnableOutput(PWM_T *pwm, uint32_t u32ChannelMask)
000000  3080              ADDS     r0,r0,#0x80
;;;435    {
;;;436        (pwm)->POEN |= u32ChannelMask;
000002  6d82              LDR      r2,[r0,#0x58]
000004  430a              ORRS     r2,r2,r1
000006  6582              STR      r2,[r0,#0x58]
;;;437    }
000008  4770              BX       lr
;;;438    
                          ENDP


                          AREA ||i.PWM_EnablePeriodInt||, CODE, READONLY, ALIGN=1

                  PWM_EnablePeriodInt PROC
;;;724     */
;;;725    void PWM_EnablePeriodInt(PWM_T *pwm, uint32_t u32ChannelNum,  uint32_t u32IntPeriodType)
000000  3080              ADDS     r0,r0,#0x80
;;;726    {
;;;727        (pwm)->INTEN0 |= (PWM_INTEN0_PIEN0_Msk << ((u32ChannelNum >> 1) << 1));
000002  6e02              LDR      r2,[r0,#0x60]
000004  084b              LSRS     r3,r1,#1
000006  005b              LSLS     r3,r3,#1
000008  21ff              MOVS     r1,#0xff
00000a  3101              ADDS     r1,#1
00000c  4099              LSLS     r1,r1,r3
00000e  430a              ORRS     r2,r2,r1
000010  6602              STR      r2,[r0,#0x60]
;;;728    }
000012  4770              BX       lr
;;;729    
                          ENDP


                          AREA ||i.PWM_EnableZeroInt||, CODE, READONLY, ALIGN=1

                  PWM_EnableZeroInt PROC
;;;782     */
;;;783    void PWM_EnableZeroInt(PWM_T *pwm, uint32_t u32ChannelNum)
000000  3080              ADDS     r0,r0,#0x80
;;;784    {
;;;785        (pwm)->INTEN0 |= (PWM_INTEN0_ZIEN0_Msk << ((u32ChannelNum >> 1) << 1));
000002  6e02              LDR      r2,[r0,#0x60]
000004  084b              LSRS     r3,r1,#1
000006  005b              LSLS     r3,r3,#1
000008  2101              MOVS     r1,#1
00000a  4099              LSLS     r1,r1,r3
00000c  430a              ORRS     r2,r2,r1
00000e  6602              STR      r2,[r0,#0x60]
;;;786    }
000010  4770              BX       lr
;;;787    
                          ENDP


                          AREA ||i.PWM_ForceStop||, CODE, READONLY, ALIGN=1

                  PWM_ForceStop PROC
;;;217     */
;;;218    void PWM_ForceStop(PWM_T *pwm, uint32_t u32ChannelMask)
000000  b570              PUSH     {r4-r6,lr}
;;;219    {
;;;220        uint32_t i;
;;;221        for(i = 0; i < PWM_CHANNEL_NUM; i ++)
000002  2200              MOVS     r2,#0
;;;222        {
;;;223            if(u32ChannelMask & (1 << i))
000004  2501              MOVS     r5,#1
                  |L36.6|
000006  462b              MOV      r3,r5
000008  4093              LSLS     r3,r3,r2
00000a  420b              TST      r3,r1
00000c  d006              BEQ      |L36.28|
;;;224            {
;;;225                (pwm)->CNTEN &= ~(1UL << ((i >> 1) << 1));
00000e  6a04              LDR      r4,[r0,#0x20]
000010  0856              LSRS     r6,r2,#1
000012  0076              LSLS     r6,r6,#1
000014  462b              MOV      r3,r5
000016  40b3              LSLS     r3,r3,r6
000018  439c              BICS     r4,r4,r3
00001a  6204              STR      r4,[r0,#0x20]
                  |L36.28|
00001c  1c52              ADDS     r2,r2,#1
00001e  2a06              CMP      r2,#6                 ;221
000020  d3f1              BCC      |L36.6|
;;;226            }
;;;227        }
;;;228    }
000022  bd70              POP      {r4-r6,pc}
;;;229    
                          ENDP


                          AREA ||i.PWM_GetADCTriggerFlag||, CODE, READONLY, ALIGN=1

                  PWM_GetADCTriggerFlag PROC
;;;306     */
;;;307    uint32_t PWM_GetADCTriggerFlag(PWM_T *pwm, uint32_t u32ChannelNum)
000000  30ff              ADDS     r0,r0,#0xff
;;;308    {
000002  3001              ADDS     r0,#1
;;;309        return (((pwm)->STATUS & (PWM_STATUS_ADCTRGF0_Msk << u32ChannelNum)) ? 1 : 0);
000004  6a00              LDR      r0,[r0,#0x20]
000006  2201              MOVS     r2,#1
000008  0412              LSLS     r2,r2,#16
00000a  408a              LSLS     r2,r2,r1
00000c  4010              ANDS     r0,r0,r2
00000e  d000              BEQ      |L37.18|
000010  2001              MOVS     r0,#1
                  |L37.18|
;;;310    }
000012  4770              BX       lr
;;;311    
                          ENDP


                          AREA ||i.PWM_GetCaptureIntFlag||, CODE, READONLY, ALIGN=1

                  PWM_GetCaptureIntFlag PROC
;;;551     */
;;;552    uint32_t PWM_GetCaptureIntFlag(PWM_T *pwm, uint32_t u32ChannelNum)
000000  30ff              ADDS     r0,r0,#0xff
;;;553    {
000002  30ff              ADDS     r0,r0,#0xff
000004  3002              ADDS     r0,#2
;;;554        return (((((pwm)->CAPIF & (PWM_CAPIF_CFLIF0_Msk << u32ChannelNum)) ? 1 : 0) << 1) | \
000006  4602              MOV      r2,r0
000008  6d40              LDR      r0,[r0,#0x54]
00000a  23ff              MOVS     r3,#0xff
00000c  3301              ADDS     r3,#1
00000e  408b              LSLS     r3,r3,r1
000010  4018              ANDS     r0,r0,r3
000012  d000              BEQ      |L38.22|
000014  2001              MOVS     r0,#1
                  |L38.22|
000016  6d52              LDR      r2,[r2,#0x54]
000018  0040              LSLS     r0,r0,#1
00001a  2301              MOVS     r3,#1
00001c  408b              LSLS     r3,r3,r1
00001e  421a              TST      r2,r3
000020  d001              BEQ      |L38.38|
;;;555                (((pwm)->CAPIF & (PWM_CAPIF_CRLIF0_Msk << u32ChannelNum)) ? 1 : 0));
000022  2101              MOVS     r1,#1
000024  e000              B        |L38.40|
                  |L38.38|
000026  2100              MOVS     r1,#0
                  |L38.40|
000028  4308              ORRS     r0,r0,r1
;;;556    }
00002a  4770              BX       lr
;;;557    /**
                          ENDP


                          AREA ||i.PWM_GetDutyIntFlag||, CODE, READONLY, ALIGN=2

                  PWM_GetDutyIntFlag PROC
;;;612     */
;;;613    uint32_t PWM_GetDutyIntFlag(PWM_T *pwm, uint32_t u32ChannelNum)
000000  3080              ADDS     r0,r0,#0x80
;;;614    {
;;;615        return ((((pwm)->INTSTS0 & ((PWM_INTSTS0_CMPDIF0_Msk | PWM_INTSTS0_CMPUIF0_Msk) << u32ChannelNum))) ? 1 : 0);
000002  6e80              LDR      r0,[r0,#0x68]
000004  4a02              LDR      r2,|L39.16|
000006  408a              LSLS     r2,r2,r1
000008  4010              ANDS     r0,r0,r2
00000a  d000              BEQ      |L39.14|
00000c  2001              MOVS     r0,#1
                  |L39.14|
;;;616    }
00000e  4770              BX       lr
;;;617    
                          ENDP

                  |L39.16|
                          DCD      0x01010000

                          AREA ||i.PWM_GetFaultBrakeIntFlag||, CODE, READONLY, ALIGN=1

                  PWM_GetFaultBrakeIntFlag PROC
;;;709     */
;;;710    uint32_t PWM_GetFaultBrakeIntFlag(PWM_T *pwm, uint32_t u32BrakeSource)
000000  3080              ADDS     r0,r0,#0x80
;;;711    {
;;;712        return (((pwm)->INTSTS1 & (0x3f << u32BrakeSource)) ? 1 : 0);
000002  6ec0              LDR      r0,[r0,#0x6c]
000004  223f              MOVS     r2,#0x3f
000006  408a              LSLS     r2,r2,r1
000008  4010              ANDS     r0,r0,r2
00000a  d000              BEQ      |L40.14|
00000c  2001              MOVS     r0,#1
                  |L40.14|
;;;713    }
00000e  4770              BX       lr
;;;714    
                          ENDP


                          AREA ||i.PWM_GetPeriodIntFlag||, CODE, READONLY, ALIGN=1

                  PWM_GetPeriodIntFlag PROC
;;;768     */
;;;769    uint32_t PWM_GetPeriodIntFlag(PWM_T *pwm, uint32_t u32ChannelNum)
000000  3080              ADDS     r0,r0,#0x80
;;;770    {
;;;771        return (((pwm)->INTSTS0 & (PWM_INTSTS0_PIF0_Msk << ((u32ChannelNum >> 1) << 1))) ? 1 : 0);
000002  6e80              LDR      r0,[r0,#0x68]
000004  084a              LSRS     r2,r1,#1
000006  0052              LSLS     r2,r2,#1
000008  21ff              MOVS     r1,#0xff
00000a  3101              ADDS     r1,#1
00000c  4091              LSLS     r1,r1,r2
00000e  4008              ANDS     r0,r0,r1
000010  d000              BEQ      |L41.20|
000012  2001              MOVS     r0,#1
                  |L41.20|
;;;772    }
000014  4770              BX       lr
;;;773    
                          ENDP


                          AREA ||i.PWM_GetWrapAroundFlag||, CODE, READONLY, ALIGN=1

                  PWM_GetWrapAroundFlag PROC
;;;946     */
;;;947    uint32_t PWM_GetWrapAroundFlag(PWM_T *pwm, uint32_t u32ChannelNum)
000000  30ff              ADDS     r0,r0,#0xff
;;;948    {
000002  3001              ADDS     r0,#1
;;;949        return (((pwm)->STATUS & (PWM_STATUS_CNTMAXF0_Msk << ((u32ChannelNum >> 1) << 1))) ? 1 : 0);
000004  6a00              LDR      r0,[r0,#0x20]
000006  084a              LSRS     r2,r1,#1
000008  0052              LSLS     r2,r2,#1
00000a  2101              MOVS     r1,#1
00000c  4091              LSLS     r1,r1,r2
00000e  4008              ANDS     r0,r0,r1
000010  d000              BEQ      |L42.20|
000012  2001              MOVS     r0,#1
                  |L42.20|
;;;950    }
000014  4770              BX       lr
;;;951    
                          ENDP


                          AREA ||i.PWM_GetZeroIntFlag||, CODE, READONLY, ALIGN=1

                  PWM_GetZeroIntFlag PROC
;;;826     */
;;;827    uint32_t PWM_GetZeroIntFlag(PWM_T *pwm, uint32_t u32ChannelNum)
000000  3080              ADDS     r0,r0,#0x80
;;;828    {
;;;829        return (((pwm)->INTSTS0 & (PWM_INTSTS0_ZIF0_Msk << ((u32ChannelNum >> 1) << 1))) ? 1 : 0);
000002  6e80              LDR      r0,[r0,#0x68]
000004  084a              LSRS     r2,r1,#1
000006  0052              LSLS     r2,r2,#1
000008  2101              MOVS     r1,#1
00000a  4091              LSLS     r1,r1,r2
00000c  4008              ANDS     r0,r0,r1
00000e  d000              BEQ      |L43.18|
000010  2001              MOVS     r0,#1
                  |L43.18|
;;;830    }
000012  4770              BX       lr
;;;831    
                          ENDP


                          AREA ||i.PWM_SetBrakePinSource||, CODE, READONLY, ALIGN=1

                  PWM_SetBrakePinSource PROC
;;;930     */
;;;931    void PWM_SetBrakePinSource(PWM_T *pwm, uint32_t u32BrakePinNum, uint32_t u32SelAnotherModule)
000000  b510              PUSH     {r4,lr}
;;;932    {
000002  3080              ADDS     r0,r0,#0x80
;;;933        (pwm)->BNF = ((pwm)->BNF & ~(PWM_BNF_BK0SRC_Msk << (u32BrakePinNum * 8))) | (u32SelAnotherModule << (PWM_BNF_BK0SRC_Pos + u32BrakePinNum * 8));
000004  6c03              LDR      r3,[r0,#0x40]
000006  00c9              LSLS     r1,r1,#3
000008  2401              MOVS     r4,#1
00000a  0424              LSLS     r4,r4,#16
00000c  408c              LSLS     r4,r4,r1
00000e  3110              ADDS     r1,r1,#0x10
000010  43a3              BICS     r3,r3,r4
000012  408a              LSLS     r2,r2,r1
000014  4313              ORRS     r3,r3,r2
000016  6403              STR      r3,[r0,#0x40]
;;;934    }
000018  bd10              POP      {r4,pc}
;;;935    
                          ENDP


                          AREA ||i.PWM_SetClockSource||, CODE, READONLY, ALIGN=1

                  PWM_SetClockSource PROC
;;;847     */
;;;848    void PWM_SetClockSource(PWM_T *pwm, uint32_t u32ChannelNum, uint32_t u32ClkSrcSel)
000000  b510              PUSH     {r4,lr}
;;;849    {
;;;850        (pwm)->CLKSRC = (pwm)->CLKSRC & ~(PWM_CLKSRC_ECLKSRC0_Msk << ((u32ChannelNum >> 1) * PWM_CLKSRC_ECLKSRC2_Pos)) | \
000002  6903              LDR      r3,[r0,#0x10]
000004  0849              LSRS     r1,r1,#1
000006  00c9              LSLS     r1,r1,#3
000008  2407              MOVS     r4,#7
00000a  408c              LSLS     r4,r4,r1
00000c  43a3              BICS     r3,r3,r4
00000e  408a              LSLS     r2,r2,r1
000010  4313              ORRS     r3,r3,r2
000012  6103              STR      r3,[r0,#0x10]
;;;851                        (u32ClkSrcSel << ((u32ChannelNum >> 1) * PWM_CLKSRC_ECLKSRC2_Pos));
;;;852    }
000014  bd10              POP      {r4,pc}
;;;853    
                          ENDP


                          AREA ||i.PWM_Start||, CODE, READONLY, ALIGN=1

                  PWM_Start PROC
;;;173     */
;;;174    void PWM_Start(PWM_T *pwm, uint32_t u32ChannelMask)
000000  b570              PUSH     {r4-r6,lr}
;;;175    {
;;;176        uint32_t i;
;;;177        for(i = 0; i < PWM_CHANNEL_NUM; i ++)
000002  2200              MOVS     r2,#0
;;;178        {
;;;179            if(u32ChannelMask & (1 << i))
000004  2501              MOVS     r5,#1
                  |L46.6|
000006  462b              MOV      r3,r5
000008  4093              LSLS     r3,r3,r2
00000a  420b              TST      r3,r1
00000c  d006              BEQ      |L46.28|
;;;180            {
;;;181                (pwm)->CNTEN |= (1UL << ((i >> 1) << 1));
00000e  6a04              LDR      r4,[r0,#0x20]
000010  0856              LSRS     r6,r2,#1
000012  0076              LSLS     r6,r6,#1
000014  462b              MOV      r3,r5
000016  40b3              LSLS     r3,r3,r6
000018  431c              ORRS     r4,r4,r3
00001a  6204              STR      r4,[r0,#0x20]
                  |L46.28|
00001c  1c52              ADDS     r2,r2,#1
00001e  2a06              CMP      r2,#6                 ;177
000020  d3f1              BCC      |L46.6|
;;;182            }
;;;183        }
;;;184    }
000022  bd70              POP      {r4-r6,pc}
;;;185    
                          ENDP


                          AREA ||i.PWM_Stop||, CODE, READONLY, ALIGN=1

                  PWM_Stop PROC
;;;195     */
;;;196    void PWM_Stop(PWM_T *pwm, uint32_t u32ChannelMask)
000000  b530              PUSH     {r4,r5,lr}
;;;197    {
;;;198        uint32_t i;
;;;199        for(i = 0; i < PWM_CHANNEL_NUM; i ++)
000002  2200              MOVS     r2,#0
;;;200        {
;;;201            if(u32ChannelMask & (1 << i))
000004  2501              MOVS     r5,#1
000006  4614              MOV      r4,r2
                  |L47.8|
000008  462b              MOV      r3,r5
00000a  4093              LSLS     r3,r3,r2
00000c  420b              TST      r3,r1
00000e  d003              BEQ      |L47.24|
;;;202            {
;;;203                (pwm)->PERIOD[((i >> 1) << 1)] = 0;
000010  0853              LSRS     r3,r2,#1
000012  00db              LSLS     r3,r3,#3
000014  181b              ADDS     r3,r3,r0
000016  631c              STR      r4,[r3,#0x30]
                  |L47.24|
000018  1c52              ADDS     r2,r2,#1
00001a  2a06              CMP      r2,#6                 ;199
00001c  d3f4              BCC      |L47.8|
;;;204            }
;;;205        }
;;;206    }
00001e  bd30              POP      {r4,r5,pc}
;;;207    
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\..\\Library\\StdDriver\\src\\pwm.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___5_pwm_c_c4896a9e____REV16|
#line 118 "..\\..\\..\\Library\\CMSIS\\Include\\core_cmInstr.h"
|__asm___5_pwm_c_c4896a9e____REV16| PROC
#line 119

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___5_pwm_c_c4896a9e____REVSH|
#line 132
|__asm___5_pwm_c_c4896a9e____REVSH| PROC
#line 133

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
